/* @autogenerated */
import { Injectable } from '@angular/core';
import { Router, ActivatedRoute, Params } from '@angular/router';
import { Observable, Subscription } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class LocalRouteStateService {
  private currentQueryParams: Params;

  constructor(
    private readonly router: Router,
    private readonly route: ActivatedRoute,
  ) {
    this.currentQueryParams = { ...this.route.snapshot.queryParams };
    this.route.queryParams.subscribe((params: Params) => {
      this.currentQueryParams = { ...params };
    });
  }

  bind(queryParamKeys: string[]): LocalRouteStateBind {
    return new LocalRouteStateBind(queryParamKeys, this.router, this.route, (params: string[]) => {
      this.cleanQueryParams(params);
    });
  }

  // Limpiar los query params del componente actual
  private cleanQueryParams(keys: string[]): void {
    keys.forEach((key) => delete this.currentQueryParams[key]);
    const res = this.currentQueryParams;
    this.router.navigate([], {
      queryParams: res,
      queryParamsHandling: 'replace', // Mantiene los query params que no estamos limpiando
    });
  }
}

export class LocalRouteStateBind {
  public constructor(
    private readonly queryParamKeys: string[],
    private router: Router,
    private route: ActivatedRoute,
    private readonly clear: (params: string[]) => void,
  ) {}

  go(path: any) {
    const onlyParams = this.filterInnerParams(path);
    const onlyExterns = this.filterOuterParams(this.route.snapshot.queryParams);
    const newQuery = { ...onlyExterns, ...onlyParams };
    this.router.navigate([], {
      queryParams: newQuery,
      queryParamsHandling: 'replace',
    });
  }

  watch(): Observable<any> {
    return new Observable((observer) => {
      const initialParams = this.readParams(this.queryParamKeys, this.route.snapshot.queryParams);
      let current = JSON.stringify(initialParams);
      setTimeout(() => {
        observer.next(initialParams);
      });
      const sus = this.route.queryParams.subscribe((params: Params) => {
        const next = this.readParams(this.queryParamKeys, params);
        const nextSign = JSON.stringify(next);
        if (nextSign !== current) {
          current = nextSign;
          observer.next(next);
        }
      });
      return () => {
        sus.unsubscribe();
        this.clear(this.queryParamKeys);
      };
    });
  }

  // Método privado para filtrar los parámetros permitidos
  private filterInnerParams(params: any): any {
    return this.filterParams(params, true);
  }
  private filterOuterParams(params: any): any {
    return this.filterParams(params, false);
  }
  private filterParams(params: any, inner: boolean): any {
    const result = {} as any;
    Object.keys(params).forEach((key) => {
      const include = this.queryParamKeys.includes(key);
      if ((inner && include) || (!inner && !include)) {
        result[key] = params[key];
      }
    });
    return result;
  }

  private readParams(queryParamKeys: string[], params: Params): any {
    const result = {} as any;
    Object.keys(params).forEach((key) => {
      if (queryParamKeys.includes(key)) {
        const value = params[key];
        result[key] = value;
      }
    });
    return result;
  }
}
