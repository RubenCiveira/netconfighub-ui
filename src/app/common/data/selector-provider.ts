/* @autogenerated */
import { signal, Signal } from '@angular/core';
import { catchError, Observable, Subscription, take, throwError } from 'rxjs';

export interface SelectorProvider<T, R> extends Signal<T[] | undefined> {
  searching: Signal<boolean>;
  error: Signal<any>;
  selection: Signal<T | null>;
  // Convierte una lista de datos remotos { uid: '12', nombre: '22', email: 'fake@mail.net' } en un { '$ref': 22 }
  search(text: string | null): void;

  // Convierte el dato bueno { '$ref': 22 } en un dato para plantilla { uid: '12', nombre: '22', email: 'fake@mail.net' } que usara
  select(value: T): void;

  // Convierte el dato remotoo en un string
  display(item: T): string;

  // Convierte el dato remoto object { uid: '12', nombre: '22', email: 'fake@mail.net' } en un { '$ref': 22 }
  value(item: T): R;

  equals(one: R, other: R): boolean;
}

export interface SelectorProviderHandler<T, R> {
  search(text: string): Observable<T[]>;

  // Convierte el dato bueno { '$ref': 22 } en un dato para plantilla { uid: '12', nombre: '22', email: 'fake@mail.net' } que usara
  select(value: R): Observable<T | undefined>;

  equals(one: R, other: R): boolean;

  // Convierte el dato remotoo en un string
  display(item: T): string;

  // Convierte el dato remoto object { uid: '12', nombre: '22', email: 'fake@mail.net' } en un { '$ref': 22 }
  value(item: T): R;
}

export function selectorProvider<T, R>(handler: SelectorProviderHandler<T, R>): SelectorProvider<T, R> {
  const searching = signal(false);
  const errors = signal(null);
  const selection = signal<T | null>(null);
  const val = signal<T[] | undefined>(undefined);
  const result = val as any;
  let subs: Subscription;
  result.search = (text: string) => {
    setTimeout(() => searching.set(true));
    subs?.unsubscribe();
    subs = handler.search(text).subscribe((values) => {
      setTimeout(() => searching.set(false));
      val.set(values);
    });
  };
  result.select = (value: R | null) => {
    if (value) {
      setTimeout(() => searching.set(true));
      subs?.unsubscribe();
      subs = handler
        .select(value)
        .pipe(
          catchError((error) => {
            console.error('There is an error', error);
            errors.set(error);
            return throwError(() => error);
          }),
        )
        .subscribe((response) => {
          setTimeout(() => searching.set(false));
          const prev = val();
          if (response && prev) {
            const match = (a: any, b: any) => JSON.stringify(a) === JSON.stringify(b);
            val.set(prev?.find((into) => match(response, into)) ? prev : [response, ...prev]);
          } else {
            val.set(response ? [response] : undefined);
          }
          selection.set(response || null);
        });
    } else {
      subs?.unsubscribe();
      val.set(undefined);
    }
  };
  result.selection = selection;
  result.searching = searching;
  result.equals = handler.equals;
  result.display = handler.display;
  result.value = handler.value;
  return result;
}
