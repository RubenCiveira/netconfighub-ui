/* @autogenerated */
import { EnvironmentInjector, inject, Injectable } from '@angular/core';
import { HttpClient, HttpEvent, HttpRequest, HttpResponse } from '@angular/common/http';
import {
  catchError,
  combineLatest,
  filter,
  finalize,
  map,
  mergeMap,
  Observable,
  of,
  take,
  tap,
  throwError,
  timeout,
} from 'rxjs';
import { AppStateService } from '@common/context/state/app-state.service';
import { AppConfigService } from '@common/context/config/app-config.service';
import { ErrorService } from '@common/context/observability/error.service';
import { propagation, trace, context, ROOT_CONTEXT, Span, SpanKind, SpanStatusCode } from '@opentelemetry/api';

@Injectable({
  providedIn: 'root',
})
export class ApiService {
  private readonly environmentInjector = inject(EnvironmentInjector);
  public constructor(
    private readonly http: HttpClient,
    private readonly appState: AppStateService,
    private readonly appConfig: AppConfigService,
    private readonly errorService: ErrorService,
  ) {}

  get<T>(endpoint: string, params?: any): Observable<T> {
    return this.send(
      new HttpRequest<T>('GET', endpoint, {
        params: params,
      }),
    );
  }

  post<T>(endpoint: string, body: any, params?: any): Observable<T> {
    return this.send(
      new HttpRequest<T>('POST', endpoint, body, {
        params: params,
      }),
    );
  }

  download(endpoint: string, params?: any): Observable<HttpResponse<Blob>> {
    return this.prepare(
      new HttpRequest('GET', endpoint, {
        params: params,
        responseType: 'blob',
      }),
    ).pipe(
      mergeMap((sreq) => this.http.request(sreq)),
      filter((event): event is HttpResponse<Blob> => event instanceof HttpResponse),
      catchError((error) => {
        this.errorService.initialiceError(error);
        return throwError(() => error);
      }),
    );
  }

  upload(endpoint: string, name: string, file: File, params?: any): Observable<HttpEvent<any>> {
    const formData: FormData = new FormData();
    formData.append(name, file);
    formData.append(name + 'Name', file.name);
    formData.append(name + 'Type', file.type);
    return this.sendUpload(
      new HttpRequest('POST', endpoint, formData, {
        params: params,
        reportProgress: true,
        responseType: 'text',
      }),
    );
  }

  put<T>(endpoint: string, body: any, params?: any): Observable<T> {
    return this.send(
      new HttpRequest<T>('PUT', endpoint, body, {
        params: params,
      }),
    );
  }

  patch<T>(endpoint: string, body: any, params?: any): Observable<T> {
    return this.send(
      new HttpRequest<T>('PATCH', endpoint, body, {
        params: params,
      }),
    );
  }

  delete<T>(endpoint: string, params?: any): Observable<T> {
    return this.send(
      new HttpRequest<T>('DELETE', endpoint, {
        params: params,
      }),
    );
  }

  private sendUpload(req: HttpRequest<any>): Observable<HttpEvent<string>> {
    return this.prepare(req).pipe(
      mergeMap((sreq) => this.http.request(sreq) as Observable<HttpEvent<string>>),
      catchError((error) => {
        this.errorService.initialiceError(error);
        return throwError(() => error);
      }),
    );
  }

  private send<T>(req: HttpRequest<T>): Observable<T> {
    return this.prepare(req).pipe(
      mergeMap((sreq) => this.trace(sreq)),
      filter((event): event is HttpResponse<T> => event instanceof HttpResponse),
      map((event) => this.convertDates((event as HttpResponse<T>).body!)),
      catchError((error) => {
        this.errorService.initialiceError(error);
        return throwError(() => error);
      }),
    );
  }

  private trace<T>(sreq: HttpRequest<T>) {
    let response = this.http.request(sreq);
    if ((sreq as any).span) {
      const span = (sreq as any).span;
      response = response.pipe(
        tap((event) => {
          if (event instanceof HttpResponse) {
            span.setAttribute('http.status_code', event.status);
            span.setStatus({ code: SpanStatusCode.OK });
          }
        }),
        catchError((error) => {
          span.setAttribute('http.status_code', error.status);
          span.setStatus({
            code: SpanStatusCode.ERROR,
            message: error.message,
          });
          return throwError(() => error);
        }),
        finalize(() => {
          span.end();
        }),
      );
    }
    return response;
  }

  private prepare<T>(req: HttpRequest<T>): Observable<HttpRequest<T>> {
    const arr: Observable<any>[] = [
      this.appConfig['api'].pipe(
        filter((val) => {
          return !!val;
        }),
      ),
      this.appState.language,
    ];
    return combineLatest(arr).pipe(mergeMap((vars, _) => this.prepareWithConf(req, vars[0], vars[1] as string)));
  }

  private convertDates(body: any): any {
    if (body === null || body === undefined) return;

    // Recorrer propiedades del objeto para encontrar y convertir fechas
    Object.keys(body).forEach((key) => {
      const value = body[key];
      if (this.isIsoDateString(value)) {
        body[key] = new Date(value);
      } else if (typeof value === 'object') {
        this.convertDates(value);
      }
    });
    return body;
  }

  private isIsoDateString(value: any): boolean {
    return (
      typeof value === 'string' &&
      (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?([+-]\d{4})?$/.test(value) ||
        /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z?$/.test(value))
    );
  }

  private prepareWithConf<T>(req: HttpRequest<T>, apiConf: any, lang: string): Observable<HttpRequest<T>> {
    let url = req.url;
    let headers = req.headers;
    let identity = '';
    let sendUid = false;
    let span: Span | null = null;
    if (apiConf) {
      Object.entries(apiConf).forEach(([key, api]: any[]) => {
        let matched = false;
        let prefix = '';
        if (url.startsWith('http://' + key)) {
          prefix = 'http://' + key;
        } else if (url.startsWith('https://' + key)) {
          prefix = 'https://' + key;
        } else if (url.startsWith(key)) {
          prefix = key;
        } else if (url.startsWith(api.url)) {
          prefix = api.url;
        }
        if (prefix.length > 0) {
          matched = true;
        }
        if (matched) {
          if (api.url) {
            url = api.url + url.substring(prefix.length);
          }
          identity = api.identity;
          sendUid = !!api.identity;
          if (api.headers) {
            for (const i of Object.keys(api.headers)) {
              headers = headers.set(i, api.headers[i]);
            }
          }
        }
      });
      if (sendUid) {
        let ctx = context.active();
        let currentSpan = trace.getSpan(ctx);

        if (!currentSpan) {
          const tracer = trace.getTracer('http-interceptor');
          span = tracer.startSpan('http-request-fallback-span', {
            kind: SpanKind.CLIENT,
          });

          ctx = trace.setSpan(ROOT_CONTEXT, span); // ¡Importante! usa ROOT_CONTEXT como base
        }
        const otelHeaders: Record<string, string> = {};
        propagation.inject(ctx, otelHeaders);
        for (const key in otelHeaders) {
          headers = headers.set(key, otelHeaders[key]);
        }
      }
    }
    if (lang) {
      headers = headers.set('Accept-Language', lang);
    }
    if (identity) {
      const maxTimeout = 250;
      return this.appState.userInfo[identity].pipe(
        filter((identity) => {
          return !!identity.token;
        }),
        take(1),
        timeout(maxTimeout), // Espera un máximo de 1 segundo
        map((identity) => {
          if (identity.token) {
            headers = headers.set('Authorization', 'Bearer ' + identity.token);
          } else {
            console.error(
              'El api requiere un token, pero no hay ninguno disponible en ' + maxTimeout + 'ms.',
              identity,
            );
          }
          const cloned = req.clone({ url, headers });
          (cloned as any).span = span;
          return cloned;
        }),
        catchError(() => of({} as any)), // Si excede el tiempo, lanza un valor con token null
      );
    } else {
      return of(req.clone({ url, headers }));
    }
  }
}
