/* @autogenerated */
import { Slide, RepositoryProvider, UploadProgress, DownloadBlob } from '../repository-provider.interface';
import { filter, map, mergeMap, Observable, switchMap, takeWhile, timer } from 'rxjs';
import { HttpEvent, HttpEventType, HttpParams, HttpResponse } from '@angular/common/http';
import { ApiService } from '@common/data/api/api.service';
import { Acl, AclAllow } from '@common/data/acl/acl.model';

export class ApiProvider<T, F> implements RepositoryProvider<T, F> {
  constructor(
    private readonly key: string,
    private readonly api: ApiService,
    private readonly bodyUrl: string,
    private readonly aclUrl: string,
  ) {}
  acl(key: string | null): Observable<Acl> {
    return this.api
      .get(this.aclUrl + (key ? '/' + key : ''))
      .pipe(map((val) => this.formatAcl(val))) as Observable<Acl>;
  }
  list(query: F): Observable<Slide<T>> {
    return (this.api.get(this.bodyUrl, new HttpParams().appendAll(query as any)) as Observable<any>).pipe(
      map((value) => {
        const queryString = value.next ? value.next.split('?')[1] : ''; // Extrae la parte despu√©s de '?'
        const next = queryString ? Object.fromEntries(new URLSearchParams(queryString)) : {};
        return {
          next: next,
          hasNext: value.hasNext,
          content: value.items,
        };
      }),
    );
  }
  retrieve(key: string): Observable<T> {
    return this.api.get(this.bodyUrl + '/' + key) as Observable<T>;
  }
  add(item: T): Observable<T> {
    return this.api.post(this.bodyUrl, item) as Observable<T>;
  }
  update(key: string, item: T): Observable<T> {
    return this.api.put(this.bodyUrl + '/' + key, item) as Observable<T>;
  }
  patch(key: string, data: any): Observable<T> {
    return this.api.patch(this.bodyUrl + '/' + key, data) as Observable<T>;
  }
  patchAllForQuery(of: string, query: F, data: any) {
    return this.api.patch(this.bodyUrl + '/~/' + of, data, new HttpParams().appendAll(query as any)).pipe(
      mergeMap((res: any) => {
        return timer(1000, 4000).pipe(
          switchMap(() => this.api.get<any>(this.bodyUrl + '/~/' + of + '-status/' + res.uid)), // Llama a la URL cada 3 segundos
          takeWhile((response: any) => response.status !== 'FAILED' && response.status !== 'FINISHED', true),
        );
      }),
    );
  }
  delete(key: string): Observable<void> {
    return this.api.delete(this.bodyUrl + '/' + key) as Observable<void>;
  }
  deleteAllForQuery(query: F): Observable<any> {
    return this.api.delete(this.bodyUrl, new HttpParams().appendAll(query as any)).pipe(
      mergeMap((res: any) => {
        return timer(1000, 4000).pipe(
          switchMap(() => this.api.get<any>(this.bodyUrl + '/~/delete-status/' + res.uid)), // Llama a la URL cada 3 segundos
          takeWhile((response: any) => response.status !== 'FAILED' && response.status !== 'FINISHED', true),
        );
      }),
    );
  }

  downloadFile(endpoint: string): Observable<DownloadBlob> {
    return this.api.download(endpoint).pipe(
      map((response: HttpResponse<Blob>) => {
        const blob = response.body!;
        const contentDisposition = response.headers.get('Content-Disposition') || '';
        const fileName = this.extractFileNameFromHeader(contentDisposition) || 'downloaded_file';
        return new DownloadBlob(blob, fileName);
      }),
    );
  }

  storeFile(endpoint: string, name: string, file: File): Observable<UploadProgress> {
    return this.api.upload(this.bodyUrl + endpoint, name, file).pipe(
      filter((event: any) => event.type === HttpEventType.UploadProgress || event.type === HttpEventType.Response),
      map((event: HttpEvent<string>) => {
        return event.type === HttpEventType.UploadProgress
          ? new UploadProgress(event.loaded, event.total)
          : new UploadProgress().innerData((event as HttpResponse<any>).body);
      }),
    );
  }

  private formatAcl(val: any): Acl {
    const allows: AclAllow[] = [];
    if (val?.allows) {
      Object.entries(val.allows).forEach(([k, v]) => {
        allows.push({
          name: (<any>v).name ? (<any>v).name : k,
          allowed: (<any>v).allowed,
          description: (<any>v).reason,
        });
      });
    }
    return {
      allows: allows,
      fields: val?.fields,
    } as Acl;
  }

  private extractFileNameFromHeader(disposition: string): string | null {
    const match = disposition.match(/filename\*?=(?:UTF-8'')?"?([^";]+)"?/i);
    if (match && match[1]) {
      try {
        return decodeURIComponent(match[1]);
      } catch {
        return match[1];
      }
    }
    return null;
  }
}
