/* @autogenerated */
import { Observable } from 'rxjs';
import { Acl } from '../../acl/acl.model';

export interface EntityMetadataReferenceInfo {
  type: string;
}

export interface EntityMetadataChildInfo {
  type: string;
  url: string;
}

export interface EntityMetadata {
  id: string;
  path?: string;
  name?: string;
  dates?: string[];
  datetimes?: string[];
  // acl?: string,
  // group?: string,
  // discriminators?: { [key: string]: string };
  // childs?: { [key: string]: EntityMetadataChildInfo };
  // references?: { [key: string]: EntityMetadataReferenceInfo };
}

/**
 * Para implementar por conectores.
 * Ejecutaran la acción que rellena los datos en crudo
 * (por ejemplo la llamada http correspondiente)
 *
 * Tiene que dar soporte a la lectura de "query" cruda
 * (sera transformada desde el objeto query por el repositorio)
 *
 * Opcionale puede dar soporte a consultas de acl, si no lo
 * proporciona, el repositorio entregará un ACL vacio en dichas
 * consultas.
 */
export interface RepositoryProvider<T, F> {
  // EntityMetadata como método.
  acl?: (key: string | null) => Observable<Acl>;
  // id(item: T): string;
  list(query: F): Observable<Slide<T>>;
  retrieve(key: string): Observable<T>;
  add(item: any): Observable<T>;
  update(key: string, item: any): Observable<T>;
  patch(key: string, data: any): Observable<T>;
  delete(key: string): Observable<void>;
  downloadFile(endpoint: string): Observable<DownloadBlob>;
  storeFile(endpoint: string, name: string, file: File): Observable<UploadProgress>;

  patchAllForQuery?: (of: string, query: F, data: any) => Observable<any>;
  deleteAllForQuery?: (query: F) => Observable<any>;
  /*
  resourceAcl?: () => Observable<Acl>;
  // wrong Name
  // specificAcl?: (id: string) => Observable<Acl>;

  count(query: any): Observable<number>;
  canAskForStatistical(): Observable<boolean>;
  statistical(aggregation: StatisticalQuery, filter: any): Observable<StatisticalResult>;

  list(query: any): Observable<Cursor<any>>;
  add(item: any): Observable<any>;
  delete(key: string): Observable<string>;
  update(key: string, item: any): Observable<any>;
  patch(key: string, data: any): Observable<any>;
  deleteAllForQuery(query: any): Observable<any>;
  patchAllForQuery(path: string, query: any, data: any): Observable<any>;
  childsOf(key: string, path: string): Observable<any[]>;

  storeFile(name: string, file: File): Observable<UploadProgress>;

  canImportContent(): Observable<boolean>;
  importContent(data: any): Observable<any>;
  storeToImportContent(file: File): Observable<UploadProgress>;

  canExportListAsFile(): Observable<boolean>;
  exportListAsFile(query: any, exportInfo: ListExport): Observable<any>;
  canExportRecordAsFile(): Observable<boolean>;
  exportRecordAsFile(key: string, exportInfo: RecordExport): Observable<any>;
  */
}

export interface Slide<T> {
  next: any;
  hasNext: boolean;
  content: T[];
}
/*
export interface ListColumn {
  title: string;
  property: string;
  visible: boolean;
}

export interface ListExport {
  name: string;
  format: 'xls';
  columns?: ListColumn[];
}

export interface RecordExport {
  name: string;
}
*/

export class DownloadBlob {
  public constructor(
    public readonly data: Blob,
    public readonly name: string,
  ) {}
}

export class UploadProgress {
  public progressPercent: number;
  public data: any;

  public constructor(value?: number, range?: number) {
    if (value && range) {
      this.progressPercent = Math.round((100 * value) / range);
    } else if (value) {
      this.progressPercent = Math.round(value);
    } else {
      this.progressPercent = 0;
    }
  }

  public innerData(data: any): UploadProgress {
    this.data = data;
    this.progressPercent = 100;
    return this;
  }
}
