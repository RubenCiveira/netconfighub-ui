/* @autogenerated */
import { Signal, signal, computed, WritableSignal } from '@angular/core';
import { Acl } from '../acl/acl.model';
import { Slide, RepositoryProvider, UploadProgress, DownloadBlob } from './provider/repository-provider.interface';
import {
  BehaviorSubject,
  filter,
  finalize,
  map,
  Observable,
  of,
  shareReplay,
  Subscriber,
  Subscription,
  take,
  tap,
} from 'rxjs';
import { Tick, Shift } from './repository.model';
import { toSignal } from '@angular/core/rxjs-interop';
import { v4 as uuidv4 } from 'uuid';

if (!(window as any).repository_store) {
  (window as any).repository_store = {};
}

export interface RepositoryMetadata<T, F> {
  key: string;
  name: string;
  provider: RepositoryProvider<T, F>;
  reference?: (name: string) => RepositoryService<any, any> | null;
}

export class RepositoryService<T, F> {
  private listMap: {
    [key: string]: { cache: CacheResource<Slide<T>>; observers: number; query: any };
  } = {};
  private resourceMap: {
    [key: string]: { cache: CacheResource<T>; observers: number };
  } = {};
  // private aclData: { cache?: CacheResource<Acl>; observers?: number } = {};
  private resourceAclData: { [key: string]: { cache: CacheResource<Acl>; observers: number } } = {};

  constructor(
    private readonly meta: RepositoryMetadata<T, F>, // private readonly name: string, // private readonly provider: RepositoryProvider<T, F>
  ) {
    if (!(window as any).repository_store[meta.name]) {
      (window as any).repository_store[meta.name] = {
        listMap: {},
        resourceMap: {},
        aclData: {},
        resourceAclData: {},
      };
    }
    this.listMap = (window as any).repository_store[meta.name].listMap;
    this.resourceMap = (window as any).repository_store[meta.name].resourceMap;
    // this.aclData = (window as any).repository_store[meta.name].aclData;
    this.resourceAclData = (window as any).repository_store[meta.name].resourceAclData;
  }

  generateComb(): string {
    const guid = uuidv4().split('-');
    const timestamp = Date.now().toString(16).slice(-12); // tomar los últimos 12 caracteres del timestamp en hexadecimal

    // Reemplazar la última parte del UUID con el timestamp
    guid[2] = timestamp.slice(0, 4);
    guid[3] = 'a' + timestamp.slice(4, 7);
    guid[4] = timestamp.slice(7, 11) + guid[4].slice(4, 12);
    return guid.join('-');
  }

  acl(): Tick<{ generic: Acl; specific: Acl }, string | null> {
    const searching = signal(false);
    let source: Subscription;
    let suscriber!: Subscriber<Acl | null>;
    const obs = new Observable<Acl | null>((obs) => {
      suscriber = obs;
      return () => {
        source?.unsubscribe();
      };
    }).pipe(
      shareReplay(1), // Compartir la última emisión con nuevos suscriptores
    );
    const res = toSignal(obs) as any; // signal<Acl|null>(null) as any;
    res.searching = searching;
    res.subscribe = (callbak: (value: Acl | null) => void) => {
      suscriber.add(
        obs.subscribe((res) => {
          callbak(res);
        }),
      );
    };
    res.reset = () => {
      setTimeout(() => searching.set(false));
      source?.unsubscribe();
      suscriber.next(null);
      return res;
    };
    const prev = { generic: null, specific: null } as any;
    res.fetch = (query: string | null) => {
      source?.unsubscribe();
      setTimeout(() => searching.set(true));
      source = this.checkAcl(query).subscribe((val) => {
        setTimeout(() => searching.set(false));
        if (query) {
          prev.specific = val;
        } else {
          prev.generic = val;
          prev.specific = null;
        }
        setTimeout(() => {
          suscriber.next({ ...prev });
        });
      });
      return res;
    };
    return res as any;
  }
  checkAcl(key: string | null): Observable<Acl> {
    if (this.meta.provider.acl) {
      return new Observable<Acl>((observer) => {
        let suscrip = new Subscription();
        const theKey = key || '--';
        if (!this.resourceAclData[theKey]) {
          this.resourceAclData[theKey] = {
            cache: new CacheResource<Acl>(this.resourceAclData, theKey, undefined),
            observers: 0,
          };
          this.resourceAclData[theKey].cache.evict();
        }
        if (this.resourceAclData[theKey].cache.isExpired()) {
          this.resourceAclData[theKey].cache.markWaiting();
          suscrip.add(
            this.meta.provider.acl!(key).subscribe((acl) => {
              this.resourceAclData[theKey].cache.touch(acl);
            }),
          );
        }
        suscrip.add(
          this.resourceAclData[theKey]
            .cache!.observable()
            .pipe(filter((v) => v !== undefined))
            .subscribe((acl) => {
              observer.next(acl);
            }),
        );
        // return this.meta.provider.acl( key );
        return () => {
          // this.resourceAclData[theKey].cache.cancelWaiting( wait );
          // suscrip.unsubscribe();
        };
      });
    } else {
      return of({ allAllowed: true });
    }
  }

  downloadFile(endpoint: string): Observable<DownloadBlob> {
    return this.meta.provider.downloadFile(endpoint);
  }

  storeFile(endpoint: string, name: string, file: File): Observable<UploadProgress> {
    return this.meta.provider.storeFile(endpoint, name, file);
  }

  add(item: T): Observable<T> {
    const key = this.itemKey(item);
    return this.meta.provider.add(item).pipe(
      take(1),
      tap((result) => {
        this.refreshAll();
        this.cacheItem(key).touch(result);
      }),
    );
  }

  deleteByKey(key: string): Observable<void> {
    return this.meta.provider.delete(key).pipe(
      take(1),
      tap((result) => {
        this.refreshAll();
        this.cacheItem(key).remove();
      }),
    );
  }

  canDeleteSelection(): boolean {
    return !!this.meta.provider.deleteAllForQuery;
  }

  deleteSelection(query: F): Observable<any> {
    const call = this.meta.provider.deleteAllForQuery;
    if (call) {
      return call.call(this.meta.provider, query).pipe(
        finalize(() => {
          // FIXME: No capta la emisión cuando termina, lo hace cuando se cierra dialogo
          // seguramente inducido por el unsubscribe del componente.
          this.refreshAll();
          this.evictItems();
        }),
      );
    } else {
      throw new Error('Unable to make deleteSelection');
    }
  }

  update(item: T): Observable<T> {
    const key = this.itemKey(item);
    return this.meta.provider.update(key, item).pipe(
      take(1),
      tap((result: any) => {
        console.log("Tras hacer update", result);
        this.cacheItem(key, result);
      }),
    );
  }

  partialByKey(key: string, args: any, path?: string): Observable<T> {
    return this.meta.provider.patch(key + (path ? '/' + path : ''), args).pipe(
      take(1),
      tap((result) => {
        this.cacheItem(key, result);
      }),
    );
  }

  canUsePartialsByKey(): boolean {
    return !!this.meta.provider.patchAllForQuery;
  }

  partialBySelection(query: F, args: any, path?: string): Observable<any> {
    const call = this.meta.provider.patchAllForQuery;
    if (call) {
      return call.call(this.meta.provider, path || '', query, args).pipe(
        finalize(() => {
          // FIXME: No capta la emisión cuando termina, lo hace cuando se cierra dialogo
          // seguramente inducido por el unsubscribe del componente.
          this.refreshAll();
          this.evictItems();
        }),
      );
    } else {
      throw new Error('Unable to make deleteSelection');
    }
  }

  values(query: F): Observable<T[]> {
    return this.list(query).pipe(map((slide) => slide?.content || []));
  }

  list(query: F): Observable<Slide<T>> {
    // let observer: Subscriber<T[]> | undefined;
    let hasNextValue = false;
    const paged = (query as any).cursor !== undefined || (query as any).since !== undefined;
    const listKey = JSON.stringify(query);
    const obs = new Observable<Slide<T>>((observer) => {
      let suscrip = new Subscription();
      // If the list is shared, we could rehuse.
      if (!this.listMap[listKey]) {
        this.listMap[listKey] = {
          observers: 0,
          query: query,
          cache: new CacheResource<Slide<T>>(this.listMap, listKey, undefined),
        };
      }
      // Load shares store query
      if (this.listMap[listKey].cache.isExpired()) {
        this.listMap[listKey].cache.markWaiting();
        suscrip.add(
          this.meta.provider.list(query).subscribe((data) => {
            let result: Slide<T> = {
              hasNext: data.content.length > 0, // data.hasNext,
              next: data.next,
              content: [],
            };
            hasNextValue = data.content.length > 0; // data.hasNext;
            if (paged && data.content.length === 0) {
              delete this.listMap[listKey];
            }
            data.content.forEach((row: any) => {
              const key = this.itemKey(row);
              const item = this.mapItem(row);
              const stored = this.cacheItem(key, item);
              let index = result.content.length;
              result.content.push(item);
              suscrip.add(
                stored.observable().subscribe((ch) => {
                  const prev = JSON.stringify(result.content[index]);
                  const curr = JSON.stringify(ch);
                  if (prev !== curr) {
                    const copy = { ...result };
                    copy.content = [...result.content];
                    copy.content[index] = ch!;
                    this.listMap[listKey].cache.touch(copy);
                    setTimeout(() => {
                      result.content[index] = ch!;
                    });
                  }
                }),
              );
              // Si este elemento cambia => also fire
            });
            if (!paged || data.content.length !== 0) {
              this.listMap[listKey].cache.touch(result);
            } else {
              observer.next(result);
            }
          }),
        );
      }
      suscrip.add(
        this.listMap[listKey].cache.observable().subscribe((val) => {
          if (val !== undefined) {
            observer.next(val);
          }
        }),
      );

      return () => {
        // this.listMap[listKey].cache.cancelWaiting(wait);
        // suscrip?.unsubscribe();
      };
    });
    const result = obs as any;
    result.next = () => {
      throw new Error('Complex results');
    };
    result.hasNext = () => hasNextValue;
    return result;
  }

  retrieve(key: string): Observable<T | undefined> {
    return this.cached(key, this.meta.provider.retrieve(key).pipe(map((item) => this.mapItem(item))));
  }

  public projections(includes: string[] = []): Shift<any, any> {
    const searching = signal(false);
    let sources = new Subscription();
    let suscriber!: Subscriber<T[]>;
    const obs = new Observable<T[]>((obs) => {
      suscriber = obs;
      return () => {
        console.log('REMOVE UNSUSCRIBES OF THE PROYECTION');
        sources.unsubscribe();
      };
    }).pipe(
      shareReplay(1), // Compartir la última emisión con nuevos suscriptores
    );
    const res = this.buildProjection(obs, includes) as any;
    res.index = -1;
    res.all = [];
    res.pages = [];
    res.query = {} as any;
    res.searching = searching;
    res.subscribe = (callbak: (value: T[] | undefined) => void) => {
      suscriber.add(
        obs.subscribe((res) => {
          callbak(res);
        }),
      );
    };
    res.reset = () => {
      setTimeout(() => searching.set(false));
      // source?.unsubscribe();
      sources.unsubscribe();
      sources = new Subscription();
      sources.add(suscriber.next([]));
      res.index = -1;
      res.all = [];
      res.pages = [];
      res.fetch(res.query);
      return res;
    };
    res.fetch = (query: F) => {
      setTimeout(() => searching.set(true));
      res.query = query;
      // source?.unsubscribe();
      sources.unsubscribe();
      sources = new Subscription();
      sources.add(
        this.list(query).subscribe((val) => {
          setTimeout(() => searching.set(false));
          res.pages = [val];
          res.index = 0;
          res.all = [...val?.content];
          suscriber.next(res.all);
        }),
      );
      return res;
    };
    res.next = () => {
      // FIXME: tengo que iterar al siguiente registro.
      // if (!searching()) {
      let current = res.pages[res.index];
      if (current?.hasNext) {
        const myindex = res.index + 1;
        res.pages[myindex] = {
          content: [],
          searching: true,
        };
        const nextParams = current?.next;
        const newQuery = { ...res.query, ...nextParams };
        setTimeout(() => searching.set(true));
        sources.add(
          this.list(newQuery).subscribe((val) => {
            setTimeout(() => searching.set(false));
            res.pages[myindex] = val;
            res.index = res.pages.length - 1;
            res.all = res.pages.flatMap((ct: any) => ct.content);
            suscriber.next(res.all);
          }),
        );
        // } else {
        // TODO: reload last page again
        //}
      }
      return res;
    };
    return res as any;
  }

  public projection(includes: string[] = []): Tick<any, any> {
    const searching = signal(false);
    let source: Subscription;
    let suscriber!: Subscriber<T | null>;
    const obs = new Observable<T>((obs) => {
      suscriber = obs;
      return () => {
        source?.unsubscribe();
      };
    }).pipe(
      shareReplay(1), // Compartir la última emisión con nuevos suscriptores
    );
    const res = this.buildProjection(obs, includes) as any;
    res.searching = searching;
    res.subscribe = (callbak: (value: T | undefined) => void) => {
      suscriber.add(
        obs.subscribe((res) => {
          callbak(res);
        }),
      );
    };
    res.reset = () => {
      setTimeout(() => searching.set(false));
      source?.unsubscribe();
      suscriber.next(null);
      return res;
    };
    res.fetch = (query: string) => {
      source?.unsubscribe();
      setTimeout(() => searching.set(true));
      source = this.retrieve(query).subscribe((val) => {
        setTimeout(() => searching.set(false));
        suscriber.next(val ? val : null);
      });
      return res;
    };
    return res as any;
  }

  private refreshAll() {
    Object.values(this.listMap).forEach((ll) => {
      // Fire again...
      ll.cache.evict();
      this.list(ll.query).subscribe();
    });
  }

  private evictItems() {
    Object.values(this.cacheItem).forEach((item) => {
      item.remove();
    });
  }

  private itemKey(item: T): string {
    return (item as any)[this.meta.key];
  }
  private mapItem(item: any): T {
    return item;
  }

  private cached(key: string, obs: Observable<T>) {
    return new Observable<T>((observer) => {
      let suscrip = new Subscription();
      const stored = this.cacheItem(key);
      if (stored.isExpired()) {
        suscrip.add(stored.wait(obs));
      }
      suscrip.add(
        stored
          .observable()
          .pipe(filter((val) => val !== undefined))
          .subscribe((val) => {
            observer.next(val);
          }),
      );
      return () => suscrip.unsubscribe();
    });
  }

  private cacheItem(key: string, item?: T): CacheResource<T> {
    if (!this.resourceMap[key]) {
      this.resourceMap[key] = {
        observers: 0,
        cache: new CacheResource<T>(this.resourceMap, key, item === null ? undefined : item),
      };
    } else if (item) {
      this.resourceMap[key].cache.touch(item);
    }
    return this.resourceMap[key].cache;
  }

  private buildProjection(
    items: Observable<T[] | T | undefined>,
    includes: string[] = [],
    suscrip?: Subscription,
  ): Signal<any> {
    let base: Signal<any>;
    if (!suscrip) {
      suscrip = new Subscription();
      const obs = new Observable((observer) => {
        suscrip!.add(
          items.subscribe((values) => {
            observer.next(values);
          }),
        );
        return () => suscrip?.unsubscribe();
      });
      base = toSignal(obs);
    } else {
      base = signal(undefined);
      // El tick se debe hacer siempre fuera del contexto
      // Tengo que recupear los datos
      suscrip!.add(
        items.subscribe((values) => {
          setTimeout(() => {
            (base as WritableSignal<any>).set(values);
          });
        }),
      );
    }
    // const base = toSignal(items);
    return computed(() => {
      const baseRef = base() as any;

      // Para cada elemento, recogo el signal que tiene por su cuenta.
      // Una primera duda es "¿cuantos signals tiene el array?" ¿Un signal de array por debajo?
      if (baseRef && this.meta.reference) {
        if (Array.isArray(baseRef)) {
          let result: any[] = [];
          baseRef?.forEach((item: any) => {
            const copy = JSON.parse(JSON.stringify(item));
            includes.forEach((include) => {
              if (item[include] && item[include]['$ref']) {
                const refRepository = this.meta.reference!(include);
                if (!refRepository) {
                  throw new Error('There is no ref repository for ' + include);
                }
                copy[include] = refRepository?.buildProjection(
                  refRepository.retrieve(item[include]['$ref']),
                  [],
                  suscrip,
                );
              } else {
                copy[include] = signal(undefined);
              }
            });
            result.push(copy);
          });
          return result;
        } else {
          const copy = JSON.parse(JSON.stringify(baseRef));
          includes.forEach((include) => {
            if (baseRef[include]['$ref']) {
              const refRepository = this.meta.reference!(include);
              if (!refRepository) {
                throw new Error('There is no ref repository for ' + include);
              }
              copy[include] = refRepository?.buildProjection(
                refRepository.retrieve(baseRef[include]['$ref']),
                [],
                suscrip,
              );
            }
          });
          return copy;
        }
      } else {
        return baseRef;
      }
    });
  }
}

class CacheResource<T> {
  private static counter = 0;
  private readonly selfref: number;
  private expires: number;
  private readonly value: BehaviorSubject<T | undefined>;

  constructor(
    private readonly resourceMap: {
      [key: string]: { cache: CacheResource<T>; observers: number };
    },
    private readonly key: string,
    value?: T,
  ) {
    this.value = new BehaviorSubject<T | undefined>(value);
    this.selfref = ++CacheResource.counter;
    this.expires = new Date().getTime() + (value ? 3600 : -3600);
  }

  evict() {
    this.expires = 0;
  }
  isExpired() {
    return this.expires < new Date().getTime();
  }

  observable(): Observable<T | undefined> {
    return new Observable((observer) => {
      const value = this.resourceMap[this.key];
      if (!value.observers) {
        value.observers = 1;
      } else {
        ++value.observers;
      }
      // Emitimos el estado actual del BehaviorSubject al nuevo suscriptor
      // observer.next(this.value.value);
      // Suscribimos el Observable al BehaviorSubject para emitir los nuevos valores
      const subscription = this.value.subscribe((value) => {
        observer.next(value);
      });
      // Función de limpieza (teardown) que se ejecutará en la desuscripción
      return () => {
        subscription.unsubscribe();
        if (--value.observers == 0) {
          delete this.resourceMap[this.key];
        }
      };
    });
  }

  remove() {
    delete this.resourceMap[this.key];
  }

  wait(obs: Observable<T>) {
    this.expires = new Date().getTime() + 3600;
    return obs.subscribe((data) => this.touch(data));
  }

  markWaiting() {
    this.expires = new Date().getTime() + 3500;
  }

  touch(value?: T) {
    const prev = JSON.stringify((this.value as BehaviorSubject<T | undefined>).value || '');
    const curr = JSON.stringify(value || '');
    if (prev !== curr) {
      (this.value as BehaviorSubject<T | undefined>).next(value);
    }
    this.expires = new Date().getTime() + 3600;
  }
}
