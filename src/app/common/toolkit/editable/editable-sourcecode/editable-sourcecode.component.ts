/* @autogenerated */
import { CommonModule } from '@angular/common';
import { AfterViewInit, Component, effect, ElementRef, input, viewChild } from '@angular/core';
import { ReactiveFormsModule } from '@angular/forms';
import { TranslocoModule } from '@jsverse/transloco';
import { BaseEditable } from '../base-editable';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';

/*
    <mat-form-field>
      <mat-label>{{ label() + '.label' | transloco }}</mat-label>
      <input
        matInput
        [required]="required()"
        placeholder="{{ label() + '.placeholder' | transloco }}"
        [formControl]="control"
      />
      @for (error of errorMessages(); track $index) {
        <mat-error>
          {{ label() + '.error.' + error | transloco }}
        </mat-error>
      }
    </mat-form-field>
*/

// 'https://cdn.jsdelivr.net/npm/monaco-editor@0.52.2/min/vs'
// /assets/monaco/vs

@Component({
  template: `
    <p>{{ label() + '.label' | transloco }}</p>
    <div #editorContainer style="width:100%; height:500px;"></div>
  `,
  selector: 'editable-sourcecode',
  imports: [ReactiveFormsModule, MatFormFieldModule, MatInputModule, CommonModule, TranslocoModule],
  providers: BaseEditable.getAccessorProvider(EditableSourcecodeComponent),
  standalone: true,
})
export class EditableSourcecodeComponent extends BaseEditable<string> implements AfterViewInit {
  private static monacoLoaded: boolean = false;
  private static monacoLoadingPromise: Promise<void> | null = null;

  public theme = input('vs-dark');
  public language = input('javascript');
  public assetsPath = input('/assets/monaco/vs');
  public editorContainer = viewChild<ElementRef<HTMLDivElement>>('editorContainer');

  private editorInstance: any;

  constructor() {
    super();
    effect(() => {
      const value = this.value();
      if (this.editorInstance) {
        const current = this.editorInstance.getValue();
        if (current != value) {
          this.editorInstance.setValue(value);
        }
      }
    });
  }

  ngAfterViewInit() {
    this.loadMonaco().then(() => {
      const monaco = (window as any).monaco;
      const div = this.editorContainer();
      if (div) {
        this.editorInstance = monaco.editor.create(div.nativeElement, {
          value: this.value(),
          language: this.language(),
          theme: this.theme(),
          automaticLayout: true,
        });
        this.editorInstance.onDidChangeModelContent(() => {
          const value = this.editorInstance.getValue();
          this.updateValue(value);
        });
      } else {
        alert('No hay div disponible para monaco editor.');
      }
    });
  }

  private loadMonaco(): Promise<void> {
    if (EditableSourcecodeComponent.monacoLoaded) {
      return Promise.resolve();
    }
    if (EditableSourcecodeComponent.monacoLoadingPromise) {
      return EditableSourcecodeComponent.monacoLoadingPromise;
    }
    EditableSourcecodeComponent.monacoLoadingPromise = new Promise<void>((resolve) => {
      const onAmdLoaderLoad = () => {
        const originalRequire = (window as any).require;
        // Guardar y aislar require AMD de Monaco
        (window as any).monacoAmdRequire = originalRequire;
        // Configurar entorno para los workers
        function getWorkerUrlFromBase(base: string, file: string): string {
          if (base.startsWith('/')) {
            // ruta relativa al dominio â†’ hacerla absoluta
            return `${window.location.origin}${base}/${file}`;
          } else if (base.startsWith('http')) {
            // ruta absoluta completa
            return `${base}/${file}`;
          } else {
            // relativo a la ruta actual (mejor evitar)
            console.warn('Ruta base relativa ambigua para Monaco:', base);
            return `${base}/${file}`;
          }
        }
        (window as any).MonacoEnvironment = {
          getWorkerUrl: function (_moduleId: string, label: string) {
            const base = this.assetsPath || '/assets/monaco/vs';
            const workerMain = `${window.location.origin}${base}/base/worker/workerMain.js`;
            const labelToWorkerId: Record<string, string> = {
              json: 'vs/language/json/jsonWorker',
              css: 'vs/language/css/cssWorker',
              html: 'vs/language/html/htmlWorker',
              typescript: 'vs/language/typescript/tsWorker',
              javascript: 'vs/language/typescript/tsWorker',
            };
            const workerId = labelToWorkerId[label] ?? 'vs/editor/editorWorker';
            return `${workerMain}?worker=${workerId}`;
          },
        };
        // Configurar ruta del loader AMD de Monaco
        (window as any).monacoAmdRequire.config({
          paths: {
            vs: this.assetsPath(),
          },
        });
        // Cargar el editor sin sobrescribir require global
        (window as any).monacoAmdRequire(['vs/editor/editor.main'], () => {
          EditableSourcecodeComponent.monacoLoaded = true;
          resolve();
        });
      };
      if (!(window as any).require) {
        const loaderScript = document.createElement('script');
        loaderScript.src = this.assetsPath() + '/loader.js';
        loaderScript.onload = onAmdLoaderLoad;
        document.body.appendChild(loaderScript);
      } else {
        onAmdLoaderLoad();
      }
    });
    return EditableSourcecodeComponent.monacoLoadingPromise;
  }
}
