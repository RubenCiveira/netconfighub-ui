/* @autogenerated */
import { Directive, effect, input } from '@angular/core';
import { BaseEditable } from './base-editable';
import { debounceTime, distinctUntilChanged, Subscription } from 'rxjs';
import { SelectorProvider } from '@common/data/selector-provider';
import { FormControl } from '@angular/forms';

@Directive({})
export abstract class SearchEditable<V, R> extends BaseEditable<R> {
  provider = input.required<SelectorProvider<V, R>>();
  search = new FormControl(null as any);

  private searchSubscription?: Subscription;
  private updateSubscription?: Subscription;
  private selectionSubscription?: Subscription;

  public constructor() {
    super();
    this.bind([this.search]);
    this.searchSubscription = this.search.valueChanges
      .pipe(distinctUntilChanged(), debounceTime(700))
      .subscribe((text) => {
        if (typeof text === 'string') {
          this.provider().search(text);
        }
      });
    effect(() => this.search.patchValue(this.provider().selection()));
    effect(() => {
      const searching = this.provider().searching();
      if (searching) {
        this.readyOptions();
      }
      setTimeout(() => {
        if (this.control.enabled) {
          this.pending.set(searching);
        }
      });
    });
  }

  get options() {
    return this.provider();
  }

  override ngOnDestroy(): void {
    this.updateSubscription?.unsubscribe();
    this.searchSubscription?.unsubscribe();
    this.selectionSubscription?.unsubscribe();
    super.ngOnDestroy();
  }

  readyOptions() {}

  searchOptions() {
    this.provider().search('');
  }

  optionSelected(option: any) {
    this.select(this.provider().value(option));
  }

  bindValueEffect() {
    effect(() => {
      const provider = this.provider();
      this.updateSubscription?.unsubscribe();
      this.updateSubscription = this.control.valueChanges.pipe(distinctUntilChanged()).subscribe((value) => {
        provider.select(value);
      });
      setTimeout(() => {
        provider.select(this.control.value);
      });
    });
  }

  blur() {
    const text = this.search.value;
    console.log('BLURR', text);
    if (!text) {
      this.select(null);
    } else if (typeof text === 'string') {
      //   const value = this.value();
      const provider = this.provider();
      const candidate = provider()?.find((item) => provider.display(item) === text);
      if (candidate) {
        this.select(provider.value(candidate));
      } else {
        this.search.patchValue(null);
        this.updateValue(null);
      }
    }
  }

  abstract select(value: R | null): void;

  compareObjects() {
    return (option1: R, option2: R) => this.compare(option1, option2);
  }

  displayItem() {
    return (item: V) => {
      return item ? this.provider().display(item) : '';
    };
  }

  compare(option1: R | null, option2: R | null) {
    return option1 !== null && option2 !== null && this.provider().equals(option1, option2);
  }
}
