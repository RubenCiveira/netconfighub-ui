/* @autogenerated */
import { CommonModule } from '@angular/common';
import { Component, contentChild, effect, input, signal, Signal, TemplateRef, WritableSignal } from '@angular/core';
import { FormGroup, ReactiveFormsModule } from '@angular/forms';
import { TranslocoModule } from '@jsverse/transloco';
import { BaseEditable } from '../base-editable';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { Subscription } from 'rxjs';
import { MatCardModule } from '@angular/material/card';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';

export interface RepeatBuilder<T> {
  newItem(): T;
  uid(item: T): string;
  formRow(item: T): FormGroup;
  visibles(item: T): Signal<any>;
}

@Component({
  template: `
    <mat-card>
      <mat-card-content>
        @for (error of errorMessages(); track $index) {
          <mat-error>
            {{ label() + 'error.' + error | transloco }}
          </mat-error>
        }

        @for (row of ids(); track row) {
          <div [ngClass]="{ small: !big(), big: big() }">
            <div class="form">
              <ng-container
                *ngTemplateOutlet="template(); context: { $implicit: forms[row], isVisible: visibles[row]() }"
              ></ng-container>
            </div>
            <div class="btn">
              <button mat-icon-button (click)="remove(provider(), row)">
                <mat-icon>remove</mat-icon>
              </button>
            </div>
          </div>
        }
      </mat-card-content>
      <mat-card-actions>
        <button mat-icon-button (click)="add()">
          <mat-icon>add</mat-icon>
        </button>
      </mat-card-actions>
    </mat-card>
  `,
  styles: [
    `
      :host {
        grid-column: 1 / -1;
      }
      :host ::ng-deep .small .form-container {
        margin: 0;
        grid-template-columns: repeat(auto-fit, minmax(10%, 1fr));
      }
      .big {
        display: flex;
      }
      .big .form {
        flex: 1;
      }
      .big .btn {
        display: flex;
        align-items: center;
        margin-bottom: 25px;
        margin-left: 20px;
      }
      .small {
        display: flex;
      }
      .small .form {
        flex: 1;
      }
      .small .btn {
        display: flex;
        align-items: center;
        margin-bottom: 25px;
        margin-left: 20px;
      }
    `,
  ],
  selector: 'editable-repeat',
  imports: [
    ReactiveFormsModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    CommonModule,
    TranslocoModule,
    MatCardModule,
  ],
  providers: BaseEditable.getAccessorProvider(EditableRepeatComponent),
  standalone: true,
})
export class EditableRepeatComponent extends BaseEditable<any[]> {
  big = input<boolean>(false);
  provider = input.required<RepeatBuilder<any>>();
  template = contentChild.required(TemplateRef);

  ids: WritableSignal<string[]> = signal([]);
  forms: any = {};
  subs: Subscription[] = [];
  visibles: any = {};

  constructor() {
    super();
    effect(() => {
      const rows = this.value();
      const ids = this.ids();
      const nids = [...ids];
      if (rows) {
        rows.forEach((element) => {
          const provider = this.provider();
          const id = provider.uid(element);
          if (!this.forms[id]) {
            nids.push(id);
            const childVis = provider.visibles(element);
            const childForm = provider.formRow(element);
            this.subs.push(
              childForm.valueChanges.subscribe((ch) => {
                this.update(this.provider(), ch);
              }),
            );
            this.forms[id] = childForm;
            this.visibles[id] = childVis;
          }
        });
      }
      if (JSON.stringify(ids) !== JSON.stringify(nids)) {
        this.ids.set(nids);
      }
    });
  }

  add() {
    const vcc: any[] = this.control.value ? [...this.control.value] : [];
    const provider = this.provider();
    const item = provider.newItem();
    vcc.push(item);
    this.updateValue(vcc as any);
  }

  remove<T>(provider: RepeatBuilder<T>, id: string) {
    const vcc: any[] = this.control.value ? [...this.control.value] : [];
    const updated: any[] = [];

    vcc.forEach((prev) => {
      const vkey = provider.uid(prev);
      if (vkey !== id) {
        updated.push(prev);
      }
    });
    this.subs.forEach((sub) => {
      sub.unsubscribe();
    });
    this.forms = {};
    this.visibles = {};
    this.ids.set([]);
    this.updateValue(updated as any);
  }

  private update<T>(provider: RepeatBuilder<T>, item: T) {
    const ikey = provider.uid(item);
    const vcc: any[] = this.control.value ? [...this.control.value] : [];
    const updated: any[] = [];
    vcc.forEach((prev) => {
      const vkey = provider.uid(prev);
      if (vkey == ikey) {
        updated.push(item);
      } else {
        updated.push(prev);
      }
    });
    this.updateValue(updated as any);
  }
}
