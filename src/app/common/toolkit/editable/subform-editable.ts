/* @autogenerated */
import { Directive, effect, input, signal } from '@angular/core';
import { FormGroup, ValidationErrors } from '@angular/forms';
import { Subscription } from 'rxjs';
import { BaseEditable } from './base-editable';

@Directive({})
export abstract class SubFormEditable<T> extends BaseEditable<T> {
  private bindSubscription?: Subscription;
  hidden = input<string[] | undefined>([]);
  fixed = input<string[] | undefined>([]);
  defined = input<{ [key: string]: any }>();
  definedFixed = signal<string[]>([]);
  definedHidden = signal<string[]>([]);

  isVisible = {} as { [key: string]: boolean };
  isEditable = {} as { [key: string]: boolean };
  outerValue: any;
  defaultValues: () => T = () => {
    return {} as T;
  };

  constructor(public readonly form: FormGroup) {
    super();
    // effect(() => {
    //   setTimeout(() => this.assignData(this.value()));
    // });
    effect(() => {
      const paramFixed = this.fixed() || [];
      const progFixed = this.definedFixed();
      const fixed = [...paramFixed, ...progFixed];
      if (this.form.controls) {
        Object.entries(this.form.controls).forEach(([name, control]) => {
          this.isEditable[name] = !fixed.includes(name);
          setTimeout(() => {
            if (this.control.disabled) {
              control.disable({ onlySelf: true });
            } else if (fixed.includes(name) && control.enabled) {
              control.disable({ onlySelf: true });
            } else if (!fixed.includes(name) && control.disabled) {
              control.enable({ onlySelf: true });
            }
          });
        });
      }
    });
    effect(() => {
      const paramHiddens = this.hidden() || [];
      const progHiddens = this.definedHidden();
      const hiddens = [...paramHiddens, ...progHiddens];
      if (this.form.controls) {
        Object.keys(this.form.controls).forEach((name) => {
          this.isVisible[name] = !hiddens.includes(name);
        });
      }
    });
  }

  override ngOnInit() {
    super.ngOnInit();
    this.control.valueChanges.subscribe((value) => {
      this.assignData(value);
    });
    this.bindSubscription?.unsubscribe();
    this.bindSubscription = this.form.valueChanges.subscribe((val) => {
      const value = this.form.getRawValue();
      if (this.form?.dirty) {
        this.updateValue(value);
      }
      this.syncFormStatus();
    });
    this.form.statusChanges.subscribe((value) => {
      this.syncFormStatus();
    });
  }

  override ngOnDestroy() {
    super.ngOnDestroy();
    this.bindSubscription?.unsubscribe();
  }

  protected assignData(assigned: any) {
    const value = assigned ?? this.defaultValues();
    const defined = this.defined();
    const filled = { ...((value as any) || {}), ...defined };
    const paramKeys = [...(defined ? Object.keys(defined) : []), ...(value ? Object.keys(value) : [])];
    Object.keys(this.form.controls).forEach((name) => {
      if (!paramKeys.includes(name)) {
        if (!this.isEditable[name]) {
          filled[name] = this.form.controls[name].value;
        } else {
          filled[name] = null;
        }
      }
    });
    Object.keys(filled).forEach((name) => {
      if (!this.form.get(name)) {
        delete filled[name];
      }
    });
    const old = JSON.stringify(this.outerValue);
    const upd = JSON.stringify(filled);
    if (old !== upd) {
      this.outerValue = filled;
      this.form.patchValue(filled, { onlySelf: true });
      this.value.set(filled);
    }
  }

  private syncFormStatus() {
    if (this.form?.dirty) {
      this.pending.set(this.form.pending);
      const errors = JSON.stringify(this.errors());
      const newErrors = {} as ValidationErrors;
      Object.entries(this.form.controls).forEach(([name, control]) => {
        if (control.errors) {
          Object.entries(control.errors).forEach(([lb, ms]) => {
            newErrors[name + '.' + lb] = ms;
          });
        }
      });
      if (errors !== JSON.stringify(newErrors)) {
        this.errors.set(newErrors);
      }
    }
  }
}
