/* @autogenerated */
import { CommonModule } from '@angular/common';
import { AfterViewInit, Component, effect, ElementRef, input, viewChild } from '@angular/core';
import { ReactiveFormsModule } from '@angular/forms';
import { TranslocoModule } from '@jsverse/transloco';
import { BaseEditable } from '../base-editable';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';

/*
    <mat-form-field>
      <mat-label>{{ label() + '.label' | transloco }}</mat-label>
      <input
        matInput
        [required]="required()"
        placeholder="{{ label() + '.placeholder' | transloco }}"
        [formControl]="control"
      />
      @for (error of errorMessages(); track $index) {
        <mat-error>
          {{ label() + '.error.' + error | transloco }}
        </mat-error>
      }
    </mat-form-field>
*/

//

@Component({
  template: `
    <div class="mat-mdc-form-field mat-mdc-form-field-type-custom mat-form-field-appearance-outline mat-primary">
      <div class="mat-mdc-text-field-wrapper mdc-text-field mdc-text-field--outlined">
        <div class="mat-mdc-form-field-flex">
          <div
            matformfieldnotchedoutline
            class="mdc-notched-outline mdc-notched-outline--notched mdc-notched-outline--upgraded"
          >
            <div class="mat-mdc-notch-piece mdc-notched-outline__leading"></div>
            <div class="mat-mdc-notch-piece mdc-notched-outline__notch">
              <label
                matformfieldfloatinglabel
                class="mdc-floating-label mat-mdc-floating-label mdc-floating-label--float-above"
                id="editorjs-label"
                for="editorjs-container"
              >
                <mat-label>Contenido</mat-label>
              </label>
            </div>
            <div class="mat-mdc-notch-piece mdc-notched-outline__trailing"></div>
          </div>

          <div
            class="mat-mdc-form-field-infix"
            style="width: 100%;height: 500px;overflow: auto;margin: 10px -10px;padding: 0 20px;"
          >
            <div #editorContainer class="editorjs-container mat-mdc-input-element mdc-text-field__input"></div>
          </div>
        </div>
      </div>

      <div class="mat-mdc-form-field-subscript-wrapper mat-mdc-form-field-bottom-align">
        <div aria-atomic="true" aria-live="polite" class="mat-mdc-form-field-hint-wrapper">
          <div class="mat-mdc-form-field-hint-spacer"></div>
        </div>
      </div>
    </div>
  `,
  selector: 'editable-markdown',
  imports: [ReactiveFormsModule, MatFormFieldModule, MatInputModule, CommonModule, TranslocoModule],
  providers: BaseEditable.getAccessorProvider(EditableMarkdownComponent),
  standalone: true,
})
export class EditableMarkdownComponent extends BaseEditable<string> implements AfterViewInit {
  private static assetsLoaded = false;
  private static loadPromise: Promise<void> | null = null;

  public assetsPath = input('/assets/editorjs');
  private editor: any;
  private markdownIt: any;

  public editorRef = viewChild<ElementRef<HTMLDivElement>>('editorContainer');

  constructor() {
    super();
    effect(() => {
      const value = this.value();
      if (this.editor) {
        this.editor.save().then((data: any) => {
          const current = this.editorDataToMarkdown(data);
          if (current != value) {
            this.markdownToEditorData(value || '').then((blocks) => {
              this.editor.render(blocks);
            });
          }
        });
      }
    });
  }

  ngAfterViewInit() {
    this.loadEditorAssets().then(() => {
      this.initEditor();
    });
  }

  private async initEditor() {
    const EditorJS = (window as any).EditorJS;
    const Header = (window as any).Header;
    const Paragraph = (window as any).Paragraph;
    const List = (window as any).EditorjsList;
    const Quote = (window as any).Quote;
    const Code = (window as any).CodeTool;

    this.markdownIt = new (window as any).markdownit();

    const el = this.editorRef();
    if (el) {
      this.editor = new EditorJS({
        holder: el.nativeElement,
        tools: {
          header: {
            class: Header,
            inlineToolbar: true,
          },
          paragraph: {
            class: Paragraph,
            inlineToolbar: true,
          },
          list: {
            class: List,
            inlineToolbar: true,
          },
          quote: {
            class: Quote,
            inlineToolbar: true,
          },
          code: {
            class: Code,
            inlineToolbar: true,
          },
        },
        placeholder: 'Escribe algo aquí...',
        autofocus: true,
        onReady: () => {
          const value = this.value();
          if (value) {
            this.markdownToEditorData(value).then((blocks) => {
              this.editor.render(blocks);
            });
          }
        },
        onChange: async () => {
          const data = await this.editor.save();
          const md = this.editorDataToMarkdown(data);
          this.updateValue(md);
        },
      });
    }
  }

  private loadEditorAssets(): Promise<void> {
    if (EditableMarkdownComponent.assetsLoaded) {
      return Promise.resolve();
    }

    if (EditableMarkdownComponent.loadPromise) {
      return EditableMarkdownComponent.loadPromise;
    }

    const loadScript = (src: string): Promise<void> =>
      new Promise((resolve, reject) => {
        const s = document.createElement('script');
        s.src = src;
        s.async = true;
        s.onload = () => resolve();
        s.onerror = () => reject(`Failed to load: ${src}`);
        document.body.appendChild(s);
      });

    const path = this.assetsPath();
    EditableMarkdownComponent.loadPromise = Promise.all([
      loadScript(`${path}/editor.min.js`),
      loadScript(`${path}/header.js`),
      loadScript(`${path}/paragraph.js`),
      loadScript(`${path}/list.js`),
      loadScript(`${path}/quote.js`),
      loadScript(`${path}/code.js`),
      loadScript(`${path}/markdown-it.min.js`),
    ]).then(() => {
      EditableMarkdownComponent.assetsLoaded = true;
    });

    return EditableMarkdownComponent.loadPromise;
  }

  private editorDataToMarkdown(data: any): string {
    const lines: string[] = [];

    for (const block of data.blocks) {
      const { type, data } = block;

      switch (type) {
        case 'header':
          lines.push(`${'#'.repeat(data.level)} ${data.text}`);
          break;

        case 'paragraph':
          lines.push(data.text);
          break;

        case 'list':
          for (const item of data.items) {
            let rawHtml = '';
            if (typeof item === 'string') {
              rawHtml = item;
            } else if ('content' in item) {
              rawHtml = item.content;
            } else if ('text' in item) {
              rawHtml = item.text;
            }
            const text = this.extractTextFromHtml(rawHtml);
            const prefix = data.style === 'ordered' ? '1. ' : '- ';
            lines.push(`${prefix}${text}`);
          }
          break;

        case 'quote':
          lines.push(`> ${data.text}`);
          break;

        case 'code':
          lines.push('```');
          lines.push(data.code);
          lines.push('```');
          break;

        case 'image':
          lines.push(`![${data.caption || ''}](${data.file?.url || ''})`);
          break;

        default:
          lines.push(`<!-- bloque no reconocido: ${type} -->`);
      }

      lines.push(''); // línea en blanco entre bloques
    }
    return lines.join('\n');
  }

  private extractTextFromHtml(html: string): string {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html || '', 'text/html');
    return doc.body.textContent?.trim() ?? '';
  }

  private async markdownToEditorData(markdown: string): Promise<any> {
    const md = new (window as any).markdownit();
    const html = md.render(markdown);

    const doc = new DOMParser().parseFromString(html, 'text/html');
    const blocks: any[] = [];

    doc.body.childNodes.forEach((node: any) => {
      if (node.nodeName.startsWith('H')) {
        blocks.push({
          type: 'header',
          data: {
            text: node.innerHTML,
            level: parseInt(node.nodeName.replace('H', ''), 10),
          },
        });
      } else if (node.nodeName === 'P') {
        blocks.push({
          type: 'paragraph',
          data: {
            text: node.innerHTML,
          },
        });
      } else if (node.nodeName === 'UL' || node.nodeName === 'OL') {
        const items = Array.from(node.children).map((li: any) => li.innerHTML);
        blocks.push({
          type: 'list',
          data: {
            style: node.nodeName === 'OL' ? 'ordered' : 'unordered',
            items,
          },
        });
      } else if (node.nodeName === 'BLOCKQUOTE') {
        blocks.push({
          type: 'quote',
          data: {
            text: node.innerHTML,
            caption: '',
            alignment: 'left',
          },
        });
      } else if (node.nodeName === 'PRE' && node.firstChild?.nodeName === 'CODE') {
        blocks.push({
          type: 'code',
          data: {
            code: node.textContent?.trim(),
          },
        });
      } else if (node.nodeName === 'IMG') {
        blocks.push({
          type: 'image',
          data: {
            file: {
              url: node.getAttribute('src'),
            },
            caption: node.getAttribute('alt') || '',
            withBorder: false,
            withBackground: false,
            stretched: false,
          },
        });
      }
    });
    return { time: Date.now(), blocks, version: '2.27.0' };
  }
}
