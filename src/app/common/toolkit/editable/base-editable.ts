/* @autogenerated */
import {
  Directive,
  effect,
  ElementRef,
  forwardRef,
  inject,
  Injector,
  input,
  OnDestroy,
  OnInit,
  Renderer2,
  signal,
} from '@angular/core';
import {
  AbstractControl,
  ControlContainer,
  ControlValueAccessor,
  FormControl,
  FormControlDirective,
  FormControlName,
  FormGroup,
  NG_VALIDATORS,
  NG_VALUE_ACCESSOR,
  NgControl,
  NgModel,
  ValidationErrors,
  Validator,
} from '@angular/forms';
import { Subscription } from 'rxjs';

@Directive({})
export abstract class BaseEditable<T> implements ControlValueAccessor, Validator, OnInit, OnDestroy {
  // Método estático para generar los providers
  static getAccessorProvider(subClass: any) {
    return [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => subClass),
        multi: true,
      },
    ];
  }
  static getValidableAccessorProvider(subClass: any) {
    return [
      {
        provide: NG_VALUE_ACCESSOR,
        useExisting: forwardRef(() => subClass),
        multi: true,
      },
      {
        provide: NG_VALIDATORS,
        useExisting: forwardRef(() => subClass),
        multi: true,
      },
    ];
  }

  label = input<string>();

  protected value = signal<T | null>(null);
  protected errors = signal<ValidationErrors | null>(null);
  protected disabled = signal(false);
  protected required = signal(false);
  protected pending = signal(false);
  protected touched = signal(false);
  protected control!: FormControl;
  protected errorMessages = signal<string[]>([]);

  private onChange = (_: T | null) => {};
  private onTouched = () => {};
  private onValidate = () => {};

  private injector = inject(Injector);
  private ngModelSyncSubscription?: Subscription;
  private statusSubscription?: Subscription;
  private binded: FormControl[] = [];

  constructor() {
    effect(() => {
      if (this.touched()) {
        this.onTouched();
      }
    });
    effect(() => {
      if (this.pending()) {
        this.control.markAsPending();
      } else {
        this.control.updateValueAndValidity();
      }
    });
    effect(() => {
      const errors = this.errors();
      this.onValidate();
    });
    const elm = this.injector.get(ElementRef);
    const ref = this.injector.get(Renderer2);
    ref.addClass(elm.nativeElement, 'editable');
    ref.addClass(elm.nativeElement, elm.nativeElement.tagName.toLowerCase());
  }

  ngOnInit() {
    const ngControl = this.injector.get(NgControl, null, {
      self: true,
      optional: true,
    });
    if (ngControl instanceof NgModel) {
      this.control = ngControl.control;
      this.ngModelSyncSubscription = ngControl.control.valueChanges.subscribe((value) => {
        if (ngControl.model !== value || ngControl.viewModel !== value) {
          ngControl.viewToModelUpdate(value);
        }
      });
    } else if (ngControl instanceof FormControlDirective) {
      this.control = ngControl.control;
    } else if (ngControl instanceof FormControlName) {
      const container = this.injector.get(ControlContainer).control as FormGroup;
      this.control = container.controls[ngControl.name!] as FormControl;
    } else {
      this.control = new FormControl();
    }
    const validators = this.control.validator;
    if (validators) {
      const requiredValidator = validators({} as any);
      this.required.set(requiredValidator && requiredValidator['required'] ? true : false);
    }
    this.statusSubscription = this.control.statusChanges.subscribe(() => {
      const prev = JSON.stringify(this.errors() || {});
      const curr = JSON.stringify(this.control.errors || {});
      if (prev !== curr) {
        this.errors.set(this.control.errors);
        this.errorMessages.set(Object.keys(this.control.errors || {}));
      }
      this.binded.forEach((ctr) => {
        if (this.control.enabled) {
          ctr.enable({ onlySelf: true });
        } else {
          ctr.disable({ onlySelf: true });
        }
      });
    });
  }

  protected updateValue(value: T | null): void {
    const prev = JSON.stringify(this.value());
    const curr = JSON.stringify(value);
    if (prev !== curr) {
      this.value.set(value);
      this.onChange(value);
    }
  }

  protected refresh() {
    const dirty = this.control.dirty;
    this.onChange(this.value());
    setTimeout(() => {
      if (!dirty) {
        this.control.markAsPristine();
      }
      this.control.updateValueAndValidity();
    });
  }

  protected bind(controls: FormControl[]) {
    this.binded.push(...controls);
  }

  registerOnValidatorChange(fn: () => void): void {
    this.onValidate = fn;
  }

  validate(_: AbstractControl): ValidationErrors | null {
    return this.errors();
  }

  ngOnDestroy() {
    this.ngModelSyncSubscription?.unsubscribe();
    this.statusSubscription?.unsubscribe();
  }

  writeValue(value: T): void {
    setTimeout(() => {
      this.value.set(value);
    });
  }

  registerOnChange(fn: (value: T | null) => void): void {
    this.onChange = fn;
  }

  registerOnTouched(fn: () => void): void {
    this.onTouched = fn;
  }

  setDisabledState(isDisabled: boolean): void {
    setTimeout(() => {
      this.disabled.set(isDisabled);
    });
  }
}
