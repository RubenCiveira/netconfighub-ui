/* @autogenerated */
import { CommonModule } from '@angular/common';
import { AfterViewInit, Component, effect, ElementRef, OnDestroy, viewChild } from '@angular/core';
import { ReactiveFormsModule } from '@angular/forms';
import { TranslocoModule } from '@jsverse/transloco';
import { BaseEditable } from '../base-editable';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';

@Component({
  template: `
    <div class="signature-wrapper">
      <canvas #canvas class="signature-canvas"></canvas>
      <button type="button" class="signature-clear" (click)="clear()">ðŸ—‘ Limpiar</button>
    </div>
  `,
  styles: [
    `
      .signature-wrapper {
        position: relative;
        border: 1px solid #ccc;
        border-radius: 4px;
        display: block;
        width: 100%;
        height: 150px;
        overflow: hidden;
      }
      .signature-canvas {
        display: block;
        width: 100%;
        height: 150px;
        background: white;
        cursor: crosshair;
        touch-action: none;
      }
      .signature-clear {
        position: absolute;
        bottom: 4px;
        right: 4px;
        background: rgba(255, 255, 255, 0.8);
        border: 1px solid #ccc;
        border-radius: 4px;
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
      }
    `,
  ],
  selector: 'editable-signature',
  imports: [ReactiveFormsModule, MatFormFieldModule, MatInputModule, CommonModule, TranslocoModule],
  providers: BaseEditable.getAccessorProvider(EditableSignatureComponent),
  standalone: true,
})
export class EditableSignatureComponent extends BaseEditable<string> implements AfterViewInit, OnDestroy {
  private canvasRef = viewChild<ElementRef<HTMLCanvasElement>>('canvas');
  private ctx!: CanvasRenderingContext2D;
  private drawing = false;

  constructor() {
    super();
    effect(() => {
      const val = this.value();
      const el = this.canvasRef();
      // if (el && this.ctx) {
      //   const current = this.getImageBase64();
      //   if (current != val) {
      //     this.draw(val);
      //   }
      // }
    });
  }

  ngAfterViewInit() {
    const canvas = this.canva();
    this.ctx = canvas.getContext('2d')!;
    window.addEventListener('resize', this.resizeCanvas.bind(this));
    setTimeout(() => {
      this.resizeCanvas();
      this.setupEvents(this.canva());
    }, 100);
  }

  override ngOnDestroy(): void {
    super.ngOnDestroy();
    window.removeEventListener('resize', this.resizeCanvas.bind(this));
  }

  public clear() {
    const canvas = this.canva();
    this.ctx.clearRect(0, 0, canvas.width, canvas.height);
    this.updateValue('');
  }

  private draw(signatureBase64: string | null) {
    const canvas = this.canva();
    this.ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (signatureBase64) {
      const [width, height] = this.sizeOf(canvas);

      const img = new Image();
      img.onload = () => this.ctx.drawImage(img, 0, 0, width, height);
      img.src = signatureBase64;
    }
  }

  private sizeOf(canvas: HTMLCanvasElement) {
    const wrapper = canvas.parentElement!;
    const rect = wrapper.getBoundingClientRect();
    const ratio = 1;
    return [rect.width * ratio, rect.height * ratio, ratio];
  }

  private resizeCanvas() {
    const canvas = this.canva();
    const [width, height, ratio] = this.sizeOf(canvas);

    canvas.width = width;
    canvas.height = height;

    canvas.style.width = `${width}px`;
    canvas.style.height = `${height}px`;

    const ctx = canvas.getContext('2d')!;
    ctx.setTransform(1, 0, 0, 1, 0, 0); // limpia transformaciones previas
    ctx.scale(ratio, ratio);

    this.ctx = ctx;
    this.draw(this.value());
  }

  private setupEvents(canvas: HTMLCanvasElement) {
    const draw = (x: number, y: number) => {
      this.ctx.lineTo(x, y);
      this.ctx.stroke();
    };

    const start = (x: number, y: number) => {
      this.ctx.beginPath();
      this.ctx.moveTo(x, y);
      this.ctx.strokeStyle = 'black';
      this.ctx.lineWidth = 2;
      this.ctx.lineCap = 'round';
      this.ctx.lineJoin = 'round';
      this.drawing = true;
    };

    const stop = () => {
      if (this.drawing) {
        this.drawing = false;
        this.updateValue(this.getImageBase64());
      }
    };

    const getPos = (e: MouseEvent | TouchEvent): { x: number; y: number } => {
      const rect = canvas.getBoundingClientRect();
      const clientX = 'touches' in e ? e.touches[0].clientX : (e as MouseEvent).clientX;
      const clientY = 'touches' in e ? e.touches[0].clientY : (e as MouseEvent).clientY;
      return {
        x: clientX - rect.left,
        y: clientY - rect.top,
      };
    };

    canvas.addEventListener('mousedown', (e) => {
      const { x, y } = getPos(e);
      start(x, y);
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!this.drawing) return;
      const { x, y } = getPos(e);
      draw(x, y);
    });

    canvas.addEventListener('mouseup', stop);
    canvas.addEventListener('mouseleave', stop);

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const { x, y } = getPos(e);
      start(x, y);
    });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const { x, y } = getPos(e);
      draw(x, y);
    });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      stop();
    });
  }

  private getImageBase64(): string {
    const canvas = this.canva();

    // Convert to black & white
    const imageData = this.ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    for (let i = 0; i < data.length; i += 4) {
      const avg = data[i] * 0.3 + data[i + 1] * 0.59 + data[i + 2] * 0.11;
      const val = avg < 128 ? 0 : 255; // Threshold for B/W
      data[i] = data[i + 1] = data[i + 2] = val;
    }
    this.ctx.putImageData(imageData, 0, 0);

    return canvas.toDataURL('image/png');
  }

  private canva(): HTMLCanvasElement {
    const el = this.canvasRef();
    if (el) {
      return el.nativeElement;
    } else {
      throw new Error('No native element build for signature');
    }
  }
}
