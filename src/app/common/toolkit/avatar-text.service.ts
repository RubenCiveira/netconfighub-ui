/* @autogenerated */

export interface AvatarSpec {
  initials: string;   // "IC"
  bg: string;         // "hsl(210, 60%, 46%)" (o "#RRGGBB")
  fg: string;         // "#000" | "#fff" según contraste
  ariaLabel: string;  // "Icono de Luisitos"
}

export function computeAvatarSpec(
  text: string,
  opts?: {
    maxLetters?: number;            // por defecto 2
    saturation?: number;            // 0..100, por defecto 60
    lightness?: number;             // 0..100, por defecto 46
    hueRange?: [number, number];    // por defecto [0, 360)
    locale?: string;                // por defecto 'es'
  }
): AvatarSpec {
  const {
    maxLetters = 2,
    saturation = 60,
    lightness = 46,
    hueRange = [0, 360],
    locale = 'es',
  } = opts || {};

  const safe = (text ?? '').trim();
  const initials = getInitials(safe, maxLetters, locale) || '•';

  // Hash determinista del texto -> número
  const hash = stringHash(safe || 'fallback');
  // Mapear hash a un tono (H) dentro del rango indicado
  const hue = hueRange[0] + (Math.abs(hash) % (hueRange[1] - hueRange[0]));

  const bg = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

  // Convertir HSL a RGB para calcular luminancia y decidir color de frente
  const [r, g, b] = hslToRgb(hue / 360, saturation / 100, lightness / 100);
  const L = relativeLuminance(r, g, b);
  const fg = L > 0.53 ? '#000' : '#fff'; // umbral razonable para buen contraste

  return {
    initials,
    bg,
    fg,
    ariaLabel: safe ? `Icono de ${safe}` : 'Icono',
  };
}

function getInitials(text: string, maxLetters: number, locale: string): string {
  if (!text) return '';
  // Normalizar, quitar espacios múltiples y signos raros al inicio/fin
  const cleaned = text
    .normalize('NFKD')
    .replace(/\p{Diacritic}/gu, '')      // quitar acentos
    .replace(/\s+/g, ' ')
    .trim();

  // Si contiene email, usa la parte antes de @
  const base = cleaned.includes('@') ? cleaned.split('@')[0] : cleaned;

  // Dividir por espacios y guiones
  const parts = base.split(/[\s\-_.]+/).filter(Boolean);

  // Si es una sola palabra, toma primeras letras de la misma palabra
  if (parts.length === 1) {
    const word = parts[0];
    // toma letras significativas (letras y números)
    const letters = Array.from(word).filter(ch => /\p{L}|\p{N}/u.test(ch));
    return letters.slice(0, maxLetters).join('').toUpperCase();
  }

  // Si hay varias palabras, toma la primera letra de las primeras N palabras significativas
  const stopwords = new Set(['de','del','la','las','el','los','the','of','da','do','dos','das','y']);
  const sig = parts
    .filter(w => !stopwords.has(w.toLowerCase()))
    .slice(0, Math.max(maxLetters, 2)) // normalmente 2
    .map(w => w[0])
    .join('')
    .toUpperCase();

  return sig.slice(0, maxLetters);
}

function stringHash(s: string): number {
  // Hash simple y rápido, determinista
  let h = 2166136261 >>> 0; // FNV-like
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h | 0;
}

function hslToRgb(h: number, s: number, l: number): [number, number, number] {
  // h, s, l in [0..1]; return RGB en [0..255]
  if (s === 0) {
    const v = Math.round(l * 255);
    return [v, v, v];
  }
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const r = hue2rgb(p, q, h + 1 / 3);
  const g = hue2rgb(p, q, h);
  const b = hue2rgb(p, q, h - 1 / 3);
  return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}
function hue2rgb(p: number, q: number, t: number): number {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}

function relativeLuminance(r255: number, g255: number, b255: number): number {
  // r,g,b en 0..255 -> luminancia relativa WCAG
  const srgb = [r255, g255, b255].map(v => v / 255).map(c =>
    c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)
  );
  return 0.2126 * srgb[0] + 0.7152 * srgb[1] + 0.0722 * srgb[2];
}
