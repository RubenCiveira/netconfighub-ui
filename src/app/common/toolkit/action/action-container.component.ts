/* @autogenerated */
import { CommonModule } from '@angular/common';
import {
  Component,
  computed,
  contentChild,
  contentChildren,
  effect,
  Injector,
  input,
  OnDestroy,
  runInInjectionContext,
  Signal,
  signal,
  TemplateRef,
  viewChild,
} from '@angular/core';
import { MatIconModule } from '@angular/material/icon';
import { Action } from './action.model';
import { MatMenuModule } from '@angular/material/menu';
import { MatButtonModule } from '@angular/material/button';
import {
  LocalRouteStateBind,
  LocalRouteStateService,
} from 'app/common/interaction/local-route-state/local-route-state.service';
import { map, Subscription } from 'rxjs';
import { SelectionModel } from 'app/common/data/selection-model';
import { toObservable } from '@angular/core/rxjs-interop';
import { BreakpointObserver, Breakpoints } from '@angular/cdk/layout';

export interface ItemMapper<T> {
  display(item: T): string;
  load(code: string): Signal<T>;
}

@Component({
  selector: 'action-container',
  standalone: true,
  imports: [MatMenuModule, MatButtonModule, MatIconModule, CommonModule],
  styleUrl: 'action-container.component.scss',
  template: `
    <ng-template #contextualTemplate let-row="row">
      @for (action of inlineActions(row); track $index) {
        @if (action.contextual && !action.multiple && action.visible([row])()) {
          @if (action.icon()) {
            <button
              mat-icon-button
              (click)="executeAction(action.name, [row])"
              [disabled]="!action.enabled(selectionModel.selected())()"
            >
              <mat-icon>{{ action.icon() }}</mat-icon>
            </button>
          } @else {
            <button
              mat-raised-button
              (click)="executeAction(action.name, [row])"
              [disabled]="!action.enabled(selectionModel.selected())()"
            >
              {{ action.label() }}
            </button>
          }
        }
      }
      @if (inlineMenu(row).length > 0) {
        <button mat-icon-button [matMenuTriggerFor]="menu" (click)="showMenu(row); $event.stopPropagation()">
          <mat-icon>more_vert</mat-icon>
        </button>
        <mat-menu #menu="matMenu">
          @for (action of inlineMenu(row); track $index) {
            @if (action.contextual && !action.multiple && action.visible([row])()) {
              <button mat-menu-item (click)="executeAction(action.name, [row])" [disabled]="!action.enabled([row])()">
                @if (action.icon()) {
                  <mat-icon>{{ action.icon() }}</mat-icon>
                }
                {{ action.label() }}
              </button>
            }
          }
        </mat-menu>
      }
    </ng-template>

    <ng-template #toolbarTemplate>
      @for (action of toolbarActions(); track $index) {
        <button
          mat-raised-button
          (click)="executeAction(action.name)"
          [disabled]="!action.enabled(selectionModel.selected())()"
        >
          @if (action.icon()) {
            <mat-icon>{{ action.icon() }}</mat-icon>
          }
          {{ action.label() }}
        </button>
      }
    </ng-template>

    <ng-template #selectionTemplate>
      @for (action of multipleActions(); track $index) {
        <button
          mat-raised-button
          (click)="executeAction(action.name, selectionModel.selected())"
          [disabled]="!action.enabled(selectionModel.selected())()"
        >
          @if (action.icon()) {
            <mat-icon>{{ action.icon() }}</mat-icon>
          }
          {{ action.label() }}
        </button>
      }
    </ng-template>

    <ng-template #activeTemplate>
      <div class="toolbar">
        <button mat-icon-button (click)="close()">
          <mat-icon>arrow_back</mat-icon>
        </button>
        <div class="toolbar-title">{{ current()?.title() }}</div>
        @for (action of dialogActions(); track $index) {
          <button
            mat-raised-button
            (click)="executeAction(action.name, selectionModel.selected())"
            [disabled]="!action.enabled(selectionModel.selected())()"
          >
            @if (action.icon()) {
              <mat-icon>{{ action.icon() }}</mat-icon>
            }
            {{ action.label() }}
          </button>
        }
        @if (dialogMenu().length > 0) {
          <button mat-icon-button [matMenuTriggerFor]="theDialogMenu">
            <mat-icon>more_vert</mat-icon>
          </button>
          <mat-menu #theDialogMenu="matMenu">
            @for (action of dialogMenu(); track $index) {
              <button
                mat-menu-item
                (click)="executeAction(action.name, selectionModel.selected())"
                [disabled]="!action.enabled(selectionModel.selected())()"
              >
                @if (action.icon()) {
                  <mat-icon>{{ action.icon() }}</mat-icon>
                }
                {{ action.label() }}
              </button>
            }
          </mat-menu>
        }
      </div>
    </ng-template>

    <div class="content">
      @if (activeRender) {
        <ng-container [ngTemplateOutlet]="theActiveTemplate() || null"></ng-container>
        <ng-container [ngTemplateOutlet]="activeRender"></ng-container>
      } @else {
        @if (masterTemplate()) {
          <ng-container [ngTemplateOutlet]="masterTemplate()!"></ng-container>
        }
      }
    </div>
  `,
})
export class ActionContainerComponent implements OnDestroy {
  maxIcons = signal(2);
  name = input<string>('container');
  mapper = input<ItemMapper<any>>();

  actions = contentChildren<Action>('action');

  contextualconSize = signal<number>(3);

  contextualActions = computed(() => {
    const actions = this.actions();
    const on = this.current();
    return actions.filter((act) => act.name != on?.name && act.contextual);
  });

  multipleActions = computed(() => {
    const actions = this.actions();
    return actions.filter(
      (action) => action.contextual && action.multiple && action.visible(this.selectionModel.selected())(),
    );
  });
  toolbarActions = computed(() => {
    const actions = this.actions();
    const max = this.maxIcons();
    return actions
      .filter((action) => !action.contextual && action.visible(this.selectionModel.selected())())
      .slice(0, max);
  });
  dialogActions = computed(() => {
    const actions = this.actions();
    const max = this.maxIcons();
    return actions
      .filter(
        (action) =>
          action.contextual &&
          !action.multiple &&
          this.selectionModel.selected().length == 1 &&
          action.visible(this.selectionModel.selected())(),
      )
      .slice(0, max);
  });
  dialogMenu = computed(() => {
    const actions = this.actions();
    const max = this.maxIcons();
    return actions
      .filter(
        (action) =>
          action.contextual &&
          !action.multiple &&
          this.selectionModel.selected().length == 1 &&
          action.visible(this.selectionModel.selected())(),
      )
      .slice(max);
  });

  activeRender?: TemplateRef<any>;
  masterTemplate = contentChild<TemplateRef<any>>('masterTemplate');

  theToolbarTemplate = viewChild<TemplateRef<any>>('toolbarTemplate');
  theActiveTemplate = viewChild<TemplateRef<any>>('activeTemplate');
  theContextTemplate = viewChild<TemplateRef<any>>('contextualTemplate');
  theSelectionTemplate = viewChild<TemplateRef<any>>('selectionTemplate');

  current = signal<Action | undefined>(undefined);

  private subs: Subscription;
  private innerSelectionModel = new SelectionModel<any>();
  private bind?: LocalRouteStateBind;
  private bindSubscription?: Subscription;
  private loadSubscription?: Subscription;

  constructor(observer: BreakpointObserver, localRouter: LocalRouteStateService, injector: Injector) {
    this.subs = new Subscription();
    // Define tus umbrales y cuántos iconos quieres en cada uno
    this.subs.add(
      observer
        .observe([
          Breakpoints.XLarge, // >=1920
          Breakpoints.Large, // 1280–1919.98
          Breakpoints.Medium, // 960–1279.98
          Breakpoints.Small, // 600–959.98
          Breakpoints.XSmall, // <600
        ])
        .pipe(
          map(({ breakpoints: bp }) => {
            if (bp[Breakpoints.XLarge]) return 5;
            if (bp[Breakpoints.Large]) return 4;
            if (bp[Breakpoints.Medium]) return 3;
            if (bp[Breakpoints.Small]) return 0;
            return 0;
          }),
        )
        .subscribe((result) => {
          this.contextualconSize.set(result);
        }),
    );
    effect(() => {
      this.actions().forEach((action) => {
        action.container.set(this);
        action.selection = this.selectionModel.selected;
      });
    });
    effect(() => {
      const theMapper = this.mapper();
      if (theMapper) {
        this.bind = localRouter.bind([this.name()]);
        this.bindSubscription?.unsubscribe();
        this.bindSubscription = this.bind.watch().subscribe((values: any) => {
          this.loadSubscription?.unsubscribe();
          // Si voy a una ruta X o Y => tengo que activar la acción y la seleccion
          if (values[this.name()]) {
            const parts = values[this.name()].split(':');
            const actionName = parts[0];
            const itemKey = parts.slice(1).join(':');
            if (itemKey) {
              setTimeout(() => {
                const loader = theMapper.load(itemKey);
                runInInjectionContext(injector, () => {
                  this.loadSubscription = toObservable(loader).subscribe((item) => {
                    if (item) {
                      this.runAction(actionName, [item]);
                    }
                  });
                });
              });
            } else {
              this.runAction(actionName);
            }
          } else {
            this.runAction();
          }
        });
      }
    });
  }

  get selectionModel() {
    return this.innerSelectionModel;
  }

  ngOnDestroy(): void {
    this.subs?.unsubscribe();
    this.bindSubscription?.unsubscribe();
    this.loadSubscription?.unsubscribe();
  }

  hasSelection() {
    return !this.current() && this.selectionModel.selected().length > 0;
  }

  hasMultiple() {
    return !!this.actions().find((act) => act.multiple);
  }

  showMenu(item: any) {
    const mapper = this.mapper();
    if (mapper) {
      mapper.load(mapper.display(item));
    }
  }

  inlineActions(row: any) {
    const actions = this.contextualActions();
    const max = this.contextualconSize();
    return actions.filter((act) => act.visible([row])()).slice(0, max);
  }

  inlineMenu(row: any) {
    const max = this.contextualconSize();
    const actions = this.contextualActions();
    return actions.filter((act) => act.visible([row])()).slice(max);
  }

  defaultAction(items: any[]) {
    const actions = this.actions();
    const posibles = actions
      .filter((act) => act.default() && this.contextMatch(act, items))
      .filter((act) => act.visible(items)())
      .filter((act) => act.enabled(items)());
    if (posibles.length > 0) {
      this.executeAction(posibles[0].name, items);
    } else {
      console.error('No default action');
    }
  }

  executeAction(name?: string, items?: any[]) {
    if (this.bind) {
      const route = {} as any;
      if (name && items && items.length > 1) {
        this.runAction(name, items);
      } else if (name && items && items.length == 1) {
        route[this.name()] = name + ':' + this.mapper()?.display(items[0]);
      } else if (name) {
        route[this.name()] = name;
      } else {
        this.current.set(undefined);
        this.activeRender = undefined;
        this.selectionModel.clearSelection();
      }
      this.bind?.go(route);
    } else {
      this.runAction(name, items);
    }
  }

  private contextMatch(act: Action, items?: any[]) {
    if (items?.length === 1) {
      return act.contextual;
    } else if ((items?.length || 0) > 1) {
      return act.multiple;
    } else {
      return !act.contextual;
    }
  }

  private runAction(name?: string, items?: any[]) {
    if (name) {
      const act = this.actions().find((action) => action.name == name);
      if (act) {
        this.selectionModel.select(items || []);
        this.execute(act);
      } else {
        console.error('Nada que ejecutar');
      }
    } else {
      this.current.set(undefined);
      this.activeRender = undefined;
      this.selectionModel.clearSelection();
    }
  }

  private execute(action: Action) {
    this.current.set(action);
    const render = action.render();
    if (render) {
      this.activeRender = render;
    }
    action.run();
  }

  close() {
    this.executeAction();
  }
}
