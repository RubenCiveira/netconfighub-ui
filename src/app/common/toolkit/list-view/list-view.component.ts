/* @autogenerated */
import {
  Component,
  computed,
  contentChildren,
  effect,
  ElementRef,
  input,
  OnDestroy,
  OnInit,
  output,
  signal,
  viewChild,
} from '@angular/core';
import { ListViewRowTemplate, ListViewTableTemplate } from './list-view.directives';
import { CommonModule } from '@angular/common';
import { BreakpointObserver, Breakpoints, LayoutModule } from '@angular/cdk/layout';
import { filter, map, pairwise, Subscription, throttleTime } from 'rxjs';
import { CdkVirtualScrollViewport, ScrollingModule } from '@angular/cdk/scrolling';
import { MatProgressBarModule } from '@angular/material/progress-bar';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { SelectionModel } from '@common/data/selection-model';
import { MatCardModule } from '@angular/material/card';
import { computeAvatarSpec, AvatarSpec } from '../avatar-text.service';
import { DisplayProvider } from '@common/data/display-provider';

@Component({
  templateUrl: 'list-view.component.html',
  styleUrls: [
    'list-view.component.scss',
    'list-view.table.component.scss',
    'list-view.grid.component.scss',
    'list-view.list.component.scss',
  ],
  selector: 'list-view',
  standalone: true,
  imports: [CommonModule, LayoutModule, ScrollingModule, MatCheckboxModule, MatProgressBarModule, MatCardModule],
})
export class ListViewComponent implements OnInit, OnDestroy {
  next = output<void>();
  prev = output<void>();
  activate = output<any>();
  // checked = output<any[]>();
  mobile = signal<boolean>(false);
  rowIcons = signal<number>(3);
  data = input.required<any[] | undefined>();
  mode = input<string>('list');
  display = input<DisplayProvider<any>>();
  selectionMultiple = input<boolean>(false);
  searching = input<boolean>();
  selectionModel = input<SelectionModel<any> | undefined>();

  tableTemplate = contentChildren(ListViewTableTemplate);
  theTableScroll = viewChild<CdkVirtualScrollViewport>('tableScroll');
  table = computed(() => {
    const theColumns = this.tableTemplate();
    return theColumns.length > 0 ? theColumns[0] : new ListViewTableTemplate();
  });

  rowTemplate = contentChildren(ListViewRowTemplate);
  theListScroll = viewChild<CdkVirtualScrollViewport>('listScroll');

  row = computed(() => {
    const theRows = this.rowTemplate();
    return theRows.length > 0 ? theRows[0] : new ListViewRowTemplate();
  });

  itemHeight = 52;

  private subs: Subscription;
  private scrollSubs = new Subscription();
  private availableWidth = signal<number>(0);
  private resizeObserver?: ResizeObserver;

  public constructor(
    observer: BreakpointObserver,
    private elRef: ElementRef,
  ) {
    this.subs = new Subscription();

    this.subs.add(
      observer.observe([Breakpoints.XSmall]).subscribe((result) => {
        this.mobile.set(result.matches);
        this.rowIcons.set(1);
      }),
    );
    this.subs.add(
      observer
        .observe([
          Breakpoints.XLarge, // >=1920
          Breakpoints.Large, // 1280–1919.98
          Breakpoints.Medium, // 960–1279.98
          Breakpoints.Small, // 600–959.98
          Breakpoints.XSmall, // <600
        ])
        .pipe(
          map(({ breakpoints: bp }) => {
            if (bp[Breakpoints.XLarge]) return 5;
            if (bp[Breakpoints.Large]) return 4;
            if (bp[Breakpoints.Medium]) return 3;
            if (bp[Breakpoints.Small]) return 0;
            return 0;
          }),
        )
        .subscribe((result) => {
          this.rowIcons.set(result + 1);
        }),
    );

    effect(() => {
      // we need to check effect on data changes
      this.data();
      this.refreshView();
      if (!this.mobile()) {
        this.calculateTableColumns();
      }
    });
  }

  ngOnInit(): void {
    const element = this.elRef.nativeElement;
    // Configurar el ancho inicial
    this.updateAvailableWidth();
    // Crear el ResizeObserver
    this.resizeObserver = new ResizeObserver(() => {
      this.updateAvailableWidth(); // Actualiza el ancho disponible
    });
    // Observar el elemento actual
    this.resizeObserver.observe(element);
    // Escuchar el evento de cambio de tamaño de la ventana
    window.addEventListener('resize', this.updateAvailableWidth);
  }

  ngOnDestroy(): void {
    this.subs.unsubscribe();
    this.scrollSubs?.unsubscribe();
    this.resizeObserver?.disconnect();
    window.removeEventListener('resize', this.updateAvailableWidth);
  }

  selectAndActivate(row: any) {
    this.selectionModel()?.select([row]);
    this.activate.emit(row);
  }

  check(row: any) {
    this.selectionModel()?.toogle(row);
  }

  isSelected(row: any) {
    return this.selectionModel()?.isSelected(row);
  }

  fallbackIcon(str: any): AvatarSpec | null {
    const displayer = this.display();
    return displayer ? computeAvatarSpec( displayer.display( str.name) ) : null;
  }

  private updateAvailableWidth = (): void => {
    const elementRect = this.elRef.nativeElement.getBoundingClientRect();
    this.availableWidth.set(elementRect.width); // Establece el ancho actual del elemento
  };

  private refreshView() {
    const tableScroll = this.theTableScroll();
    const listScroll = this.theListScroll();
    const scroll = tableScroll ?? listScroll;
    const searching = this.searching();
    if (scroll) {
      scroll.checkViewportSize();
      this.attachScroll(searching || false, scroll);
    }
  }

  private attachScroll(searching: boolean, scroller: CdkVirtualScrollViewport) {
    const frameSize = 240;
    setTimeout(() => {
      if (
        !searching &&
        scroller.measureScrollOffset('bottom') < frameSize &&
        scroller.measureViewportSize('vertical') > frameSize
      ) {
        this.next.emit();
      }
      this.scrollSubs?.unsubscribe();
      this.scrollSubs = scroller
        .elementScrolled()
        .pipe(
          map(() => scroller.measureScrollOffset('bottom')),
          pairwise(),
          filter(([y1, y2]) => y2 < y1 && y2 < frameSize),
          throttleTime(200),
        )
        .subscribe({
          next: () => {
            if (scroller.measureViewportSize('vertical') > frameSize) {
              this.next.emit();
            }
          },
        });
    });
  }

  private calculateTableColumns() {
    let defWidth = 42;
    let checks = this.selectionMultiple() ? 52 : 0;
    const table = this.table();
    const columns = table.columns();
    const width = this.availableWidth() - checks;
    let managedWith = 0;
    let expandableColumns = 0;
    columns.forEach((column) => {
      const factor = column.factor();
      if (factor > 0) {
        expandableColumns += factor;
      }
      if (column.title()) {
        managedWith += column.width();
      } else {
        managedWith += defWidth * this.rowIcons();
      }
    });
    let excesive = width - managedWith;
    const toRemove = [...columns];
    toRemove.forEach((item, index) => {
      (item as any).originalIndex = index;
    });
    toRemove.sort((a, b) => {
      if (b.factor() !== a.factor()) {
        return b.factor() - a.factor();
      }
      if (b.width() !== a.width()) {
        return b.width() - a.width();
      }
      return (b as any).originalIndex - (a as any).originalIndex;
    });
    expandableColumns = 0;
    toRemove.forEach((column) => {
      if (excesive < 0 && column.title()) {
        column.visible = false;
        excesive += column.width();
      } else {
        if (column.title()) {
          ++expandableColumns;
        }
        column.visible = true;
      }
    });
    let each = Math.floor(excesive / (expandableColumns || columns.length));
    columns.forEach((column) => {
      const factor = column.factor();
      const width = column.title() ? column.width() : defWidth * this.rowIcons();
      column.displayHeight = this.itemHeight;
      if (!expandableColumns) {
        column.displayWidth = width + each;
      } else if (column.title()) {
        column.displayWidth = width + factor * each;
      } else {
        column.displayWidth = width;
      }
    });
  }
}
