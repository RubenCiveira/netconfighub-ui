/* @autogenerated */
import { Injectable, Injector, ErrorHandler } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { MatSnackBar } from '@angular/material/snack-bar';
import { ErrorModalComponent } from '@common/toolkit/error-modal/error-modal.component';
import { SpanStatusCode } from '@opentelemetry/api';
import { AppConfigService } from '../config/app-config.service';
import { InstrumentationService } from './instrumentation.service';

export interface HiddenError {
  hidden: boolean;
}

@Injectable({ providedIn: 'root' })
export class ErrorService {
  private displayedError = true;

  constructor(
    private dialog: MatDialog,
    private snackBar: MatSnackBar,
    private appConfig: AppConfigService,
    private provider: InstrumentationService,
  ) {}

  public storeError(error: any) {
    console.error('Store error', error);
    const msg = error.message || 'Error no especificado';
    this.appConfig['name'].subscribe((name) => {
      console.log('HAS TRACER');
      const tracer = this.provider.getTracer(msg);
      const span = tracer.startSpan(msg);
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: msg,
      });
      span.recordException(error); // Esto registrarÃ¡ el stack trace y otros detalles del error
      span.end();
    });
  }

  public notifyError(message: string) {
    this.snackBar.open(message, 'OK', { duration: 5000 });
  }

  private debugError(error: any) {
    this.storeError(error);
    // this.displayedError = true;
    console.error('Error ', error);
    if (error.status === 422) {
      this.snackBar
        .open('Ha ocurrido un error, la lista de datos enviados es incorrecta', undefined, { duration: 2000 })
        .afterDismissed()
        .subscribe({
          next: () => {
            this.displayedError = false;
          },
        });
    } else {
      this.dialog
        .open(ErrorModalComponent, { data: { error: error } })
        .afterClosed()
        .subscribe({
          next: () => {
            this.displayedError = false;
          },
        });
    }
  }

  public cancelError(error: any) {
    clearTimeout(error.timeout);
    delete error.timeout;
  }

  public isCanceled(error: any) {
    return !!error.timeout;
  }

  public initialiceError(error: any) {
    error.timeout = setTimeout(() => {
      if (!error.hidden) {
        this.debugError(error);
      }
    }, 2000);
  }
}

@Injectable()
export class GlobalErrorHandler implements ErrorHandler {
  constructor(private injector: Injector) {}

  handleError(error: any) {
    const service = this.injector.get(ErrorService);
    service.storeError(error);
  }
}
