/* @autogenerated */
import { APP_INITIALIZER, Injectable, InjectionToken } from '@angular/core';
import { environment } from 'app/bootstrap/enviroment/enviroment';
import { BehaviorSubject, map, Observable } from 'rxjs';

export const STATIC_CONF: InjectionToken<string> = new InjectionToken<string>('STATIC_CONF');

export function provideConfiguration() {
  return [
    {
      provide: APP_INITIALIZER,
      useFactory: (appConfig: _$$_AppConfigService) => {
        return () => appConfig.$$_loadConfig();
      },
      deps: [_$$_AppConfigService],
      multi: true,
    },
    {
      provide: STATIC_CONF,
      deps: [_$$_AppConfigService],
      useFactory: (app: _$$_AppConfigService) => {
        return app.staticValue();
      },
    },
  ];
}

@Injectable({ providedIn: 'root' })
class _$$_AppConfigService {
  private values = new BehaviorSubject<any>(null);
  private shell = false;
  private loaded = false;
  private env: any;

  public constructor() {
    this.env = environment;
  }

  public staticValue() {
    if (!this.shell) {
      throw new Error('Static configuration is only available on the shell');
    }
    return this.values.value;
  }

  // Método para cargar la configuración
  public async $$_loadConfig(): Promise<void> {
    this.shell = true;
    const response = await fetch('./config/' + this.env.name + '-config.json');
    const config = await response.json();
    // Actualizar el signal con los datos cargados
    let env = environment;
    this.values.next(this.deepMerge(env, config));
  }

  public registerRemote(name: string, url: string, file: string) {
    if (!(window as any)._remove_mfa_config_url) {
      (window as any)._remove_mfa_config_url = {};
    }
    (window as any)._remove_mfa_config_url[name] = [url, file];
  }

  // Función para consultar una clave específica de la configuración
  public value(key: string, def?: string): Observable<any> {
    if (!this.shell) {
      if (!this.loaded) {
        this.loaded = true;
        this.mfeLoad();
      }
    }
    return this.values.pipe(
      map((node) => {
        const path = key.split('.');
        path.forEach((p) => {
          node = node ? node[p] : null;
        });
        return node ?? def;
      }),
    );
  }

  private mfeLoad() {
    let name = this.env.name;
    let remote = (window as any)._remove_mfa_config_url
      ? (window as any)._remove_mfa_config_url[name][0] + (window as any)._remove_mfa_config_url[name][1]
      : '';
    (async () => {
      const response = await fetch(remote);
      const config = await response.json();
      this.values.next(this.deepMerge(this.env, config));
    })();
  }

  private deepMerge(target: any, source: any): any {
    if (typeof target !== 'object' || typeof source !== 'object') {
      return source !== undefined ? source : target;
    }

    for (const key in source) {
      if (source.hasOwnProperty(key)) {
        if (typeof source[key] === 'object' && !Array.isArray(source[key])) {
          // Si es un objeto, hacemos merge recursivo
          target[key] = this.deepMerge(target[key] || {}, source[key]);
        } else {
          // Si es un valor primitivo o array, sobrescribir
          target[key] = source[key];
        }
      }
    }

    return target;
  }
}

@Injectable({ providedIn: 'root' })
export class AppConfigService {
  [key: string]: Observable<any>;
  public constructor(base: _$$_AppConfigService) {
    return new Proxy(
      {},
      {
        get: (_, prop) => {
          return base.value(prop as string);
        },
      },
    );
  }
}

@Injectable({ providedIn: 'root' })
export class MicroFrontConfigService {
  public constructor(private readonly base: _$$_AppConfigService) {}
  public registerRemote(name: string, url: string, file: string) {
    this.base.registerRemote(name, url, file);
  }
}
