/* @autogenerated */
import { inject, Injectable, Injector, Provider } from '@angular/core';
import {
  InlineLoader,
  LangDefinition,
  Translation,
  TRANSLOCO_CONFIG,
  TRANSLOCO_SCOPE,
  TranslocoConfig,
  translocoConfig,
  TranslocoLoader,
  TranslocoService,
} from '@jsverse/transloco';
import { HttpClient } from '@angular/common/http';
import { environment } from 'app/bootstrap/enviroment/enviroment';
import { firstValueFrom, forkJoin, map, of, take } from 'rxjs';
import { STATIC_CONF } from './app-config.service';
import { AppStateService } from '../state/app-state.service';

@Injectable({ providedIn: 'root' })
export class I18nLoaderService implements TranslocoLoader {
  private http = inject(HttpClient);
  private conf = inject(TRANSLOCO_CONFIG);
  private inj = inject(Injector);

  getTranslation(path: string) {
    const pathParts = path.split('/');
    const lang = pathParts.pop() || '';
    const scope = pathParts.join('/');
    // Dinamic append of language if is no available
    if (!(this.conf.availableLangs as string[]).includes(lang)) {
      const translocoService = this.inj.get(TranslocoService);
      translocoService.setAvailableLangs([...(this.conf.availableLangs as string[]), lang]);
    }
    // Merge upper languajes
    return forkJoin(
      langsPath(lang, this.conf).map((part) => this.http.get<Translation>(this.url(scope, part)).pipe(take(1))),
    ).pipe(map((translations) => translations.reduce((acc, curr) => this.deepMerge(acc, curr), {})));
  }

  private url(scope: string, path: string) {
    let name = environment.name;
    const target = (scope === '' ? '' : '/' + scope) + '/' + path;
    return (window as any)._remove_mfa_config_url && (window as any)._remove_mfa_config_url[name]
      ? (window as any)._remove_mfa_config_url[name][0] + 'i18n' + target + '.json'
      : 'i18n' + target + '.json';
  }

  private deepMerge(target: any, source: any): any {
    for (const key of Object.keys(source)) {
      if (typeof source[key] === 'object' && !Array.isArray(source[key]) && typeof target[key] === 'object') {
        // If both are objects: deepMerge again
        target[key] = this.deepMerge(target[key], source[key]);
      } else {
        // If is a primitive value: override
        target[key] = source[key];
      }
    }
    return target;
  }
}

/**
 * @deprecated seems that nobody use these on nowhere
 */
export function translocoScopeProvider(name: string, alias: string, baseLang: string, langs: string[]): Provider {
  return {
    provide: TRANSLOCO_SCOPE,
    useFactory: (trx: TranslocoService, http: HttpClient) => {
      const info = {} as InlineLoader;
      // Tengo que sacar los idiomas por defecto...
      langs.forEach((lang) => {
        info[lang] = () => {
          let remote =
            ((window as any)._remove_mfa_config_url
              ? (window as any)._remove_mfa_config_url[environment.name][0]
              : '') +
            'i18n/' +
            name +
            '.' +
            lang +
            '.json';
          return firstValueFrom(http.get<Translation>(remote));
        };
      });
      const availables = trx.getAvailableLangs();
      availables.forEach((lang) => {
        const val = (lang as LangDefinition).id ?? (lang as string);
        if (!info[val]) {
          info[val] = info[baseLang];
        }
      });
      return {
        scope: alias,
        loader: info,
        alias: alias,
      };
    },
    deps: [TranslocoService, HttpClient, AppStateService],
  };
}
export function provideI18nConfiguration() {
  return [
    {
      provide: TRANSLOCO_CONFIG,
      deps: [STATIC_CONF],
      useFactory: (conf: any) => buildTranslocoConfig(conf['i18n']),
    },
  ];
}

function buildTranslocoConfig(conf: any): TranslocoConfig {
  const baseLang = conf['default-lang'] ?? 'en';
  const availables = conf['available-langs'] ?? ['en', 'es'];
  if (!availables.includes(baseLang)) {
    availables.push(baseLang);
  }
  return translocoConfig({
    availableLangs: availables,
    defaultLang: baseLang,
    reRenderOnLangChange: true,
    prodMode: false,
  });
}

function langsPath(failedLang: string, config: TranslocoConfig): string[] {
  const lang = failedLang.split('/').pop() || '';
  const baseLang = lang.split('-');
  const paths: string[] = [config.defaultLang];
  let preffix = '';
  baseLang.forEach((part) => {
    preffix += (preffix.length == 0 ? '' : '-') + part;
    if (!paths.includes(preffix) && (config.availableLangs as string[]).includes(preffix)) {
      paths.unshift(preffix);
    }
  });
  return paths;
}
