/* @autogenerated */
import { HttpRequest } from '@angular/common/http';
import { AppConfigService } from '@common/context/config/app-config.service';
import { AuthConfig, OAuthService } from 'angular-oauth2-oidc';
import { Observable, ReplaySubject, combineLatest, from, map, of } from 'rxjs';
import { IdentityHandler, IdentityProvider } from '../identity-provider.interface';
import { AppStateService } from '@common/context/state/app-state.service';
import { ErrorService } from '@common/context/observability/error.service';
import { UserInfo } from '../user-info.model';

export class OidcIdentityProviderService implements IdentityProvider {
  constructor(
    private oauthService: OAuthService,
    private config: AppConfigService,
    private appState: AppStateService,
    private errors: ErrorService,
  ) {}

  accept(type: string, name: string): IdentityHandler | null {
    if (type === 'oidc') {
      const result = new OidcIdentityHandlerService(name, this.oauthService, this.config, this.appState, this.errors);
      result.configure();
      return result;
    } else {
      return null;
    }
  }
}

export class OidcIdentityHandlerService implements IdentityHandler {
  private logged: boolean | undefined = undefined;
  private boostrapSubject = new ReplaySubject<void>();
  private currentUser: UserInfo = {};
  constructor(
    private readonly name: string,
    private readonly oauthService: OAuthService,
    private readonly config: AppConfigService,
    private readonly appState: AppStateService,
    private readonly errors: ErrorService,
  ) {
    this.oauthService.events.subscribe((e) => {
      if (e.type === 'user_profile_loaded' || e.type === 'discovery_document_loaded') {
        // this.incomingLogin();
      } else if (e.type === 'token_expires') {
        console.log('ERROR, token expires');
        if ((e as any).info === 'access_token') {
          setTimeout(() => {
            this.oauthService.refreshToken().catch(console.error);
          }, 1000);
          // console.log( this.oauthService );
        }
      } else if (e.type === 'token_received') {
        this.updateToken();
      } else if (e.type === 'logout') {
        this.appState.userInfo[this.name].set({});
      } else if (e.type === 'invalid_nonce_in_state') {
        // this.oauthService.initImplicitFlow();
        this.oauthService.initCodeFlow();
      } else if (e.type === 'silently_refreshed') {
        this.incomingLogin();
      } else if (e.type === 'token_refresh_error') {
        this.currentUser = {};
        this.appState.userInfo[this.name].set(this.currentUser);
        this.boostrapSubject.next();
      } else if (e.type === 'discovery_document_load_error') {
        this.currentUser = {};
        this.appState.userInfo[this.name].set(this.currentUser);
        this.boostrapSubject.next();
        alert('UNABLE TO LOAD OIDC');
      } else if (e.type === 'silent_refresh_error') {
        // if (e.reason?.params?.error) {
        //   const messageWithSpaces = e.reason.params.error.replace(/\+/g, ' ');
        //   this.errors.notifyError(decodeURIComponent(messageWithSpaces));
        // }
        this.oauthService.logOut(true);
        this.appState.userInfo[this.name].set({});
      } else {
        console.log('EVENTO OIDC', e);
      }
    });
  }

  bootstrap(): Observable<void> {
    return this.boostrapSubject;
  }

  accept(type: string): boolean {
    return 'oidc' == type;
  }

  login(): void {
    this.oauthService.initCodeFlow();
  }

  logout(): void {
    this.oauthService.revokeTokenAndLogout();
  }

  autenticateInHttp(req: HttpRequest<any>): Observable<HttpRequest<any>> {
    if (req.url.startsWith(this.oauthService.issuer || 'nop')) {
      return of(req);
    } else {
      if (this.oauthService.hasValidAccessToken()) {
        var token = this.oauthService.getAccessToken();
        const headers = req.headers.set('Authorization', 'Bearer ' + token);
        return of(req.clone({ url: req.url, headers }));
      } else {
        return from(this.oauthService.refreshToken()).pipe(
          map((_) => {
            var token = this.oauthService.getAccessToken();
            const headers = req.headers.set('Authorization', 'Bearer ' + token);
            return req.clone({ url: req.url, headers });
          }),
        );
      }
    }
  }

  public configure() {
    const arr: Observable<any>[] = [this.appState.tenant, this.config['identity.' + this.name]];
    combineLatest(arr).subscribe((vals: any[]) => {
      this.configureForTenant(vals[0] as string, vals[1]);
    });
  }

  private configureForTenant(tenant: string, setup: any) {
    const config: AuthConfig = {
      responseType: 'code',
      redirectUri: setup['redirect'] ?? this.currentUrl(),
      issuer: this.forCurrent(setup['issuer'], tenant),
      requireHttps: !!setup['force-https'],
      // The SPA's id. The SPA is registerd with this id at the auth-server
      clientId: setup['client-id'],
      // this.oauthService.responseType = 'token';
      // set the scope for the permissions the client should request
      // The first three are defined by OIDC. The 4th is a usecase-specific one
      scope: setup['scope'] + ' offline_access',
      // set to true, to receive also an id_token via OpenId Connect (OIDC) in addition to the
      // OAuth2-based access_token
      oidc: true,
      timeoutFactor: 0.75,
      // useSilentRefresh: false,
      showDebugInformation: true,
      // silentRefreshRedirectUri: window.location.origin + '/silent-refresh.html',
      disablePKCE: false, // setup['pkce'];
    };
    if (setup['audience']) {
      config.customQueryParams = {
        audience: setup['audience'],
      };
    }
    if (setup['persistent']) {
      this.oauthService.setStorage(localStorage);
    } else {
      this.oauthService.setStorage(sessionStorage);
    }
    this.oauthService.configure(config);
    this.oauthService.loadDiscoveryDocumentAndTryLogin().then(() => {
      this.incomingLogin();
    });
  }

  private forCurrent(str: string, tenant: string) {
    return str.replace('{{tenant}}', tenant);
  }

  private currentUrl() {
    var location = window.location;
    return location.protocol + '//' + location.host + location.pathname + location.search;
  }

  private updateToken() {
    if (this.currentUser.authenticated) {
      const newUser = { ...this.currentUser };
      newUser.token = this.oauthService.getAccessToken();
      this.appState.userInfo[this.name].set(newUser);
    } else {
      this.incomingLogin();
    }
  }

  private incomingLogin() {
    const valid = this.oauthService.hasValidAccessToken();
    if (valid != this.logged) {
      this.logged = valid;
      if (valid) {
        this.oauthService.loadUserProfile().then((info: any) => {
          this.currentUser = {
            name: info.info.name,
            email: info.info.email,
            authenticated: true,
            token: this.oauthService.getAccessToken(),
            roles: info.info.groups || ['guest'],
          };
          this.appState.userInfo[this.name].set(this.currentUser);
          this.boostrapSubject.next();
        });
      } else {
        this.currentUser = {};
        this.appState.userInfo[this.name].set(this.currentUser);
        this.boostrapSubject.next();
      }
    }
  }
}
