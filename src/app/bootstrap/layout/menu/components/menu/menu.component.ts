/* @autogenerated */
import { Component, computed, input, OnDestroy, Signal } from '@angular/core';
import { toSignal } from '@angular/core/rxjs-interop';
import { Router, RouterModule } from '@angular/router';
import { AppConfigService } from '@common/context/config/app-config.service';
import { IdentityService } from '@common/context/identity/identity.service';
import { AppStateService } from '@common/context/state/app-state.service';
import { MatButtonModule } from '@angular/material/button';
import { MatMenuModule } from '@angular/material/menu';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatRippleModule } from '@angular/material/core';
import { MatIconModule } from '@angular/material/icon';
import { CommonModule } from '@angular/common';
import { Subscription } from 'rxjs';
import { MenuItem } from 'app/bootstrap/layout/container/model/menu-item.model';
import { RouteAccessService } from 'app/bootstrap/layout/container/service/route-accesible.service';

@Component({
  selector: 'app-menu',
  standalone: true,
  imports: [
    CommonModule,
    RouterModule,
    MatButtonModule,
    MatExpansionModule,
    MatIconModule,
    MatRippleModule,
    MatMenuModule,
  ],
  templateUrl: './menu.component.html',
  styleUrl: './menu.component.scss',
})
export class MenuComponent implements OnDestroy {
  mode = input<string>('full');
  items = input<MenuItem[] | undefined>();
  title: Signal<string | undefined>;
  currentLanguage: Signal<string | undefined>;
  currentTenant: Signal<string | undefined>;

  menu = computed(() => {
    this.subscriptions.unsubscribe();
    this.subscriptions = new Subscription();
    const items = this.items();
    const result = [] as any[];
    if (items) {
      items.forEach((item) => {
        result.push(this.copyItem(item));
      });
    }
    return result;
  });

  private subscriptions = new Subscription();

  public constructor(
    private readonly appstate: AppStateService,
    private readonly router: Router,
    private readonly identity: IdentityService,
    private readonly checker: RouteAccessService,
    appconfig: AppConfigService,
  ) {
    this.title = toSignal(appconfig['meta.title']);
    this.currentLanguage = toSignal(appstate.language);
    this.currentTenant = toSignal(appstate.tenant);
  }

  ngOnDestroy(): void {
    this.subscriptions.unsubscribe();
  }

  public run(item: any, event: any): void {
    console.log(item);
    if (item.route) {
      this.go([item.route]);
    } else {
      alert('No route');
    }
  }

  public go(route: any[]): void {
    const target = [this.currentLanguage(), this.currentTenant(), ...route];
    this.router.navigate(target);
  }

  public idioma(label: string): void {
    this.appstate.language.set(label);
  }

  public tenant(name: string): void {
    this.appstate.tenant.set(name);
  }

  public login(): void {
    this.identity.login('main');
  }

  public logout(): void {
    this.identity.logout('main');
  }

  private childsVisibility(item: any) {
    item.hidden = !item.childs.find((i: any) => !i.hidden);
    item.active = item.childs.find((i: any) => i.active);
  }

  private copyItem(item: MenuItem, parent?: any) {
    const copy = {
      label: item.label,
      icon: item.icon,
      route: item.route,
      hidden: false,
      childs: [],
    } as any;

    if (item.route) {
      copy.active = this.checker.isUrlActive(this.currentLanguage() + '/' + this.currentTenant() + '/' + item.route);
      this.subscriptions.add(
        this.checker
          .checkRouteGuards(this.currentLanguage() + '/' + this.currentTenant() + '/' + item.route)
          .subscribe((res) => {
            copy.hidden = res !== true;
            if (parent) {
              this.childsVisibility(parent);
            }
          }),
      );
      this.subscriptions.add(
        this.router.events.subscribe((ch) => {
          copy.active = this.checker.isUrlActive(
            this.currentLanguage() + '/' + this.currentTenant() + '/' + item.route,
          );
          if (parent) {
            this.childsVisibility(parent);
          }
        }),
      );
    }
    if (item.subItems) {
      item.subItems.forEach((sitem) => {
        copy.childs.push(this.copyItem(sitem, copy));
      });
    }
    if (!item.route) {
      this.childsVisibility(copy);
    }
    return copy;
  }
}
