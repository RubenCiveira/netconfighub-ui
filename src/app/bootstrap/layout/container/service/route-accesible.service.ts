/* @autogenerated */
import { Injectable, Injector, runInInjectionContext } from '@angular/core';
import { Router, ActivatedRouteSnapshot, Route, UrlTree, CanActivateFn } from '@angular/router';
import { Observable, of } from 'rxjs';

@Injectable({
  providedIn: 'root',
})
export class RouteAccessService {
  constructor(
    private readonly router: Router,
    private readonly injector: Injector,
  ) {}

  // Método para encontrar la ruta coincidente y evaluar los guards
  checkRouteGuards(url: string): Observable<boolean | UrlTree> {
    const route = this.findMostSpecificRoute(url, this.router.config);
    if (!route) {
      // Si no se encuentra ninguna ruta, no es accesible
      return of(false);
    }
    // Evaluar los guards asociados a la ruta
    const canActivateGuards = route.canActivate || [];

    // Ejecutar guards canActivate
    for (const guard of canActivateGuards) {
      const guardInstance = guard as CanActivateFn;
      // Si el guard devuelve false o una UrlTree, la ruta no es accesible
      const result = runInInjectionContext(this.injector, () =>
        guardInstance(new ActivatedRouteSnapshot(), this.router.routerState.snapshot),
      );
      // const result = guardInstance(new ActivatedRouteSnapshot(), this.router.routerState.snapshot);
      if (result instanceof UrlTree || result === false) {
        return of(false);
      } else if (result instanceof Observable) {
        return result as Observable<boolean | UrlTree>;
      }
    }
    // Si no se han encontrado problemas, la ruta es accesible
    return of(true);
  }

  // Método para verificar si la URL coincide con la ruta activa
  isUrlActive(url: string): boolean {
    const route = this.findMostSpecificRoute(url, this.router.config);

    if (!route) {
      return false; // No hay ruta que coincida
    }

    // Obtener la ruta activa
    const activeRouteSnapshot = this.router.routerState.snapshot.root;
    // Verificar si la ruta coincide con la ruta activa
    return this.isRouteActive(route, activeRouteSnapshot);
  }

  private isRouteActive(route: Route, activeRouteSnapshot: ActivatedRouteSnapshot): boolean {
    // Comparar por la routeConfig, que define la configuración de la ruta
    if (activeRouteSnapshot.routeConfig === route) {
      return true;
    }

    // Recursivamente verificar en los hijos si hay coincidencias
    for (const childSnapshot of activeRouteSnapshot.children) {
      if (this.isRouteActive(route, childSnapshot)) {
        return true;
      }
    }

    return false;
  }

  // Método para encontrar la ruta más específica que coincida con la URL
  private findMostSpecificRoute(url: string, routes: Route[]): Route | undefined {
    for (const route of routes) {
      const routePath = route.path;

      if (routePath && this.matchUrlToRoute(routePath, url)) {
        const remainingUrl = this.getRemainingUrl(routePath, url);

        // Si hay rutas hijas, buscar en ellas
        if (route.children && remainingUrl !== '') {
          const childRoute = this.findMostSpecificRoute(remainingUrl, route.children);
          if (childRoute) {
            return childRoute;
          }
        }

        return route; // Si no hay hijos o no hay coincidencia más específica, devolver la ruta actual
      }
    }
    return undefined;
  }

  // Método para verificar si la URL coincide con la ruta
  private matchUrlToRoute(routePath: string | undefined, url: string): boolean {
    if (!routePath) {
      return false;
    }
    const routeSegments = routePath.split('/');
    const urlSegments = url.split('/');
    return routeSegments.every((segment, index) => segment === urlSegments[index] || segment.startsWith(':'));
  }

  // Método para obtener la URL restante después de hacer match con la ruta padre
  private getRemainingUrl(routePath: string, url: string): string {
    const routeSegments = routePath.split('/');
    const urlSegments = url.split('/');

    // Retirar la parte que ya hizo match con la ruta padre
    const remainingSegments = urlSegments.slice(routeSegments.length);

    return remainingSegments.join('/');
  }
}
